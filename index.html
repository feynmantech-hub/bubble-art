<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D æ³¡æ³¡ V7.2 (è¶…äº®å·¨å¤§ç‰ˆ)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: "å¾®è»Ÿæ­£é»‘é«”", sans-serif; user-select: none; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 100; pointer-events: none; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }

        #version-tag {
            position: absolute; top: 10px; right: 10px; color: #888; font-size: 12px; font-weight: bold;
        }

        #start-screen {
            pointer-events: auto; background: rgba(30,30,30,0.9);
            padding: 50px; border-radius: 25px; text-align: center;
            border: 2px solid #ffdd00; box-shadow: 0 0 80px rgba(255,220,0,0.5);
        }

        h1 {
            color: #fff; margin: 0 0 15px 0; font-size: 2.5rem;
            text-shadow: 0 0 20px #ffdd00;
        }

        #btn-start {
            background: linear-gradient(to right, #ffcc00, #ffeb3b); color: #000; border: none; padding: 20px 60px; font-size: 1.5rem;
            border-radius: 40px; cursor: pointer; margin-top: 30px; font-weight: bold;
            box-shadow: 0 10px 30px rgba(255,200,0,0.6); transition: 0.2s;
        }
        #btn-start:hover { transform: scale(1.05); box-shadow: 0 15px 40px rgba(255,220,0,0.8); }

        #instructions {
            position: absolute; top: 20px; width: 100%; text-align: center;
            opacity: 0; transition: opacity 1s; pointer-events: none;
            color: white; text-shadow: 0 2px 10px #000;
        }
        
        #wind-arrow {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 8rem; color: rgba(255,255,255,0.3); font-weight: bold;
            opacity: 0; transition: opacity 0.3s; pointer-events: none;
        }

        #mic-indicator {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 300px; height: 10px; background: #333;
            border-radius: 5px; overflow: hidden; opacity: 0; transition: opacity 1s;
        }
        #mic-level {
            width: 0%; height: 100%; background: linear-gradient(90deg, #ffdd00, #ffffff); transition: width 0.05s;
        }

        video { position: absolute; opacity: 0; pointer-events: none; }
    </style>

    <script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-layer">
        <div id="version-tag">V7.2 Ultra Bright & Giant</div>
        <div id="wind-arrow">â¤</div>
        
        <div id="start-screen">
            <h1>ğŸŒŸ è¶…äº®å·¨å¤§æ³¡æ³¡</h1>
            <p style="color:#ccc; font-size: 1.2rem;">è«‹å˜—è©¦å·¦å³è½‰é ­å¹æ°£</p>
            <button id="btn-start" onclick="initExperience()">é–‹å•Ÿé«”é©—</button>
        </div>

        <div id="instructions">
            <div style="font-size: 1.8rem; font-weight: bold; margin-bottom:10px;">ğŸ˜® è©¦è‘—å¾€å³æˆ–å¾€å·¦å¹æ°£</div>
            <div style="font-size: 1.2rem; color: #eee;">ğŸ‘† é»æ“Šæ³¡æ³¡æˆ³ç ´å®ƒ</div>
        </div>
        <div id="mic-indicator"><div id="mic-level"></div></div>
    </div>

    <video id="input-video" playsinline webkit-playsinline muted></video>

    <script>
        let scene, camera, renderer;
        let bubbles = [];
        let audioContext, analyser, dataArray;
        let isBlowingMouth = false, isBlowingMic = false, micVolume = 0;
        let windDirectionX = 0;
        let mouthPosition = new THREE.Vector3(0, -3, 0); 
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        async function initExperience() {
            const btn = document.getElementById('btn-start');
            btn.innerText = "æš–æ©Ÿä¸­...";
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: 640, height: 480 }, audio: true });
                document.getElementById('input-video').srcObject = stream;
                document.getElementById('input-video').play();
                setupAudio(stream);
                initThreeJS(); 
                initAI(document.getElementById('input-video'));
                
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('instructions').style.opacity = 1;
                document.getElementById('mic-indicator').style.opacity = 1;
                window.addEventListener('pointerdown', onPointerDown);
            } catch (err) {
                alert("éŒ¯èª¤: " + err.message);
                btn.innerText = "é‡è©¦";
            }
        }

        function setupAudio(stream) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaStreamSource(stream);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            source.connect(analyser);
            dataArray = new Uint8Array(analyser.frequencyBinCount);
        }

        function updateMic() {
            if (!analyser) return;
            analyser.getByteFrequencyData(dataArray);
            let sum = 0;
            for(let i = 0; i < dataArray.length; i++) sum += dataArray[i];
            micVolume = sum / dataArray.length;
            document.getElementById('mic-level').style.width = Math.min(micVolume*1.2, 100) + '%';
            isBlowingMic = micVolume > 12; 
        }

        function onPointerDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            // V7.2: å¢åŠ å°„ç·šæª¢æ¸¬çš„å®¹éŒ¯ç‡ï¼Œæ›´å®¹æ˜“é»åˆ°å¤§æ³¡æ³¡
            raycaster.params.Sphere.threshold = 0.5;

            const intersects = raycaster.intersectObjects(bubbles.map(b => b.mesh));
            if (intersects.length > 0) {
                const targetBubble = bubbles.find(b => b.mesh === intersects[0].object);
                if (targetBubble) targetBubble.pop();
            }
        }

        // --- æè³ª ---
        const bubbleGeo = new THREE.SphereGeometry(1, 64, 64);
        let bubbleMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, 
            transmission: 1.0,  
            opacity: 1.0,
            transparent: true,
            roughness: 0.0,
            metalness: 0.2, // ç¨å¾®å¢åŠ é‡‘å±¬æ„Ÿï¼Œè®“åå…‰æ›´å¼·
            thickness: 0.2, 
            ior: 1.5,
            reflectivity: 1,
            iridescence: 1.2, // å¢å¼·è™¹å½©
            iridescenceIOR: 1.33,
            iridescenceThicknessRange: [100, 1000],
            clearcoat: 1.0,
            clearcoatRoughness: 0
        });

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
            camera.position.z = 6; // V7.2: ç›¸æ©Ÿç¨å¾®æ‹‰é ï¼Œä»¥å®¹ç´æ›´å¤§çš„æ³¡æ³¡

            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            
            // V7.2: å¤§å¹…å¢åŠ æ•´é«”æ›å…‰åº¦
            renderer.toneMappingExposure = 2.5; 
            
            document.body.appendChild(renderer.domElement);

            // --- V7.2 ç‡ˆå…‰æ¥µè‡´å¢å¼· ---
            
            // 1. ç’°å¢ƒå…‰ï¼šå¤§å¹…å¢å¼·
            scene.add(new THREE.AmbientLight(0xffffff, 2.0)); 

            // 2. ä¸»è§’é»å…‰æºï¼šå¼·åº¦ç¿»å€ï¼Œç¯„åœåŠ å¤§
            const pointLight = new THREE.PointLight(0xffdd00, 50, 300); 
            pointLight.position.set(15, 5, 10);
            scene.add(pointLight);

            // 3. è¼ªå»“å…‰ï¼šå¢å¼·
            const rimLight = new THREE.DirectionalLight(0x8888ff, 10); 
            rimLight.position.set(-10, 0, -5);
            scene.add(rimLight);
            
            // 4. åº•éƒ¨è£œå…‰ (æ–°å¢)ï¼šè®“æ³¡æ³¡åº•éƒ¨ä¹Ÿäº®èµ·ä¾†
            const bottomLight = new THREE.DirectionalLight(0xffffff, 3);
            bottomLight.position.set(0, -10, 0);
            scene.add(bottomLight);

            animate();
        }

        class Bubble {
            constructor() {
                this.mesh = new THREE.Mesh(bubbleGeo, bubbleMat);
                
                // --- V7.2 æ³¡æ³¡å·¨å¤§åŒ– ---
                // èˆŠç‰ˆ 0.6~1.2 -> æ–°ç‰ˆ 1.5~3.0 (è®Šå¤§ 2.5 å€!)
                const size = 1.5 + Math.random() * 1.5;
                this.mesh.scale.set(size, size, size);
                
                // ç”Ÿæˆä½ç½®
                const startX = mouthPosition.x * 4; // é…åˆç›¸æ©Ÿæ‹‰é ï¼Œèª¿æ•´åº§æ¨™æ¯”ä¾‹
                const startY = mouthPosition.y * 4;
                this.mesh.position.set(startX + (Math.random()-0.5)*0.5, startY, 0);
                
                const windForce = windDirectionX * 0.1;
                
                this.velocity = new THREE.Vector3(
                    windForce + (Math.random()-0.5)*0.02, 
                    0.04 + Math.random() * 0.03,          
                    (Math.random()-0.5)*0.02              
                );

                this.wobbleOffset = Math.random() * 100;
                this.isPopping = false;
                this.popScale = 1.0;
                scene.add(this.mesh);
            }

            update() {
                if (this.isPopping) {
                    this.popScale *= 1.25;
                    this.mesh.scale.setScalar(this.popScale * this.mesh.scale.x);
                    if(this.popScale > 4) return false;
                    return true;
                }

                const boost = (micVolume / 100) * 0.01;
                this.velocity.y += boost;
                this.velocity.x += windDirectionX * 0.003; 

                this.mesh.position.add(this.velocity);
                this.velocity.multiplyScalar(0.985); 
                this.velocity.y += 0.0008; 

                const wobble = Math.sin(Date.now()*0.004 + this.wobbleOffset)*0.08;
                this.mesh.scale.setScalar(this.mesh.scale.x + wobble*0.005);
                
                // V7.2: æ“´å¤§ç§»é™¤é‚Šç•Œ (å› ç‚ºæ³¡æ³¡å¾ˆå¤§)
                return (this.mesh.position.y < 12 && Math.abs(this.mesh.position.x) < 15);
            }
            pop() { if(!this.isPopping) this.isPopping = true; }
            dispose() { scene.remove(this.mesh); }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateMic();
            
            const arrow = document.getElementById('wind-arrow');
            if (Math.abs(windDirectionX) > 0.2) {
                arrow.style.opacity = 0.7;
                arrow.innerText = windDirectionX > 0 ? "â¤" : "â—„";
                arrow.style.transform = `translate(-50%, -50%) translateX(${windDirectionX * 80}px)`;
            } else {
                arrow.style.opacity = 0;
            }

            // ç¨å¾®é™ä½ç”Ÿæˆé »ç‡ï¼Œé¿å…å¤§æ³¡æ³¡å¤ªæ“æ“ 
            if ((isBlowingMouth || isBlowingMic) && Math.random() > 0.88) bubbles.push(new Bubble());
            
            for (let i = bubbles.length - 1; i >= 0; i--) {
                if (!bubbles[i].update()) { bubbles[i].dispose(); bubbles.splice(i, 1); }
            }
            renderer.render(scene, camera);
        }

        function initAI(videoElement) {
            const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
            faceMesh.setOptions({maxNumFaces: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
            
            faceMesh.onResults((results) => {
                if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                    const lm = results.multiFaceLandmarks[0];

                    const mouthH = Math.hypot(lm[13].x - lm[14].x, lm[13].y - lm[14].y);
                    const mouthW = Math.hypot(lm[61].x - lm[291].x, lm[61].y - lm[291].y);
                    isBlowingMouth = ((mouthH/mouthW) > 0.3 && mouthH > 0.01); // V7.2: é™ä½ä¸€é»å¹æ°£é–€æª»ï¼Œæ›´å®¹æ˜“è§¸ç™¼

                    const leftFaceZ = lm[454].z;
                    const rightFaceZ = lm[234].z;
                    const yaw = (leftFaceZ - rightFaceZ) * 12; 
                    windDirectionX += (yaw - windDirectionX) * 0.15; // V7.2: åŠ å¿«è½‰é ­åæ‡‰é€Ÿåº¦

                    const mouthX = -(lm[13].x - 0.5) * 2; 
                    const mouthY = -(lm[13].y - 0.5) * 2; 
                    mouthPosition.set(mouthX, mouthY, 0);
                }
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await faceMesh.send({image: videoElement}); }, width: 640, height: 480
            });
            cameraUtils.start();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
