<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D å¹æ³¡æ³¡äº’å‹•è—è¡“</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: "å¾®è»Ÿæ­£é»‘é«”", sans-serif; user-select: none; }
        
        /* ä»‹é¢å±¤ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 100; pointer-events: none; /* è®“é»æ“Šèƒ½ç©¿é€åˆ° 3D å±¤ */
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }

        /* é–‹å§‹æŒ‰éˆ• (åˆå§‹é¡¯ç¤º) */
        #start-screen {
            pointer-events: auto;
            background: rgba(0,0,0,0.7);
            padding: 40px; border-radius: 20px; text-align: center;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        #btn-start {
            background: linear-gradient(135deg, #00c6ff, #0072ff);
            color: white; border: none; padding: 15px 40px; font-size: 1.5rem;
            border-radius: 30px; cursor: pointer; margin-top: 20px;
            box-shadow: 0 4px 15px rgba(0,114,255,0.4); transition: transform 0.2s;
        }
        #btn-start:active { transform: scale(0.95); }

        /* æ“ä½œæŒ‡å¼• (å•Ÿå‹•å¾Œé¡¯ç¤º) */
        #instructions {
            position: absolute; top: 20px; width: 100%; text-align: center;
            opacity: 0; transition: opacity 1s; pointer-events: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8); color: white;
        }
        .hint-text { font-size: 1.1rem; margin: 5px; color: rgba(255,255,255,0.9); }
        .sub-hint { font-size: 0.9rem; color: rgba(255,255,255,0.6); }

        /* éº¥å…‹é¢¨éŸ³é‡æ¢ (è¦–è¦ºå›é¥‹) */
        #mic-indicator {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 200px; height: 10px; background: rgba(255,255,255,0.2);
            border-radius: 5px; overflow: hidden; opacity: 0; transition: opacity 1s;
        }
        #mic-level {
            width: 0%; height: 100%; background: #00ff88; transition: width 0.1s;
        }

        video { position: absolute; opacity: 0; pointer-events: none; }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-layer">
        <div id="start-screen">
            <h1 style="color:white; margin:0;">ğŸ«§ äº’å‹•æ³¡æ³¡è—è¡“</h1>
            <p style="color:#ccc;">è«‹å…è¨±ç›¸æ©Ÿèˆ‡éº¥å…‹é¢¨æ¬Šé™</p>
            <button id="btn-start" onclick="initExperience()">é–‹å§‹é«”é©—</button>
        </div>

        <div id="instructions">
            <div class="hint-text">ğŸ˜® å°è‘—éº¥å…‹é¢¨å˜Ÿå˜´å¹æ°£</div>
            <div class="sub-hint">ğŸ‘† é»æ“Šæ³¡æ³¡å¯ä»¥æˆ³ç ´å®ƒ</div>
        </div>

        <div id="mic-indicator"><div id="mic-level"></div></div>
    </div>

    <video id="input-video" playsinline webkit-playsinline muted></video>

    <script>
        // --- å…¨åŸŸè®Šæ•¸ ---
        let scene, camera, renderer;
        let bubbles = [];
        let windSpeed = 0;
        let audioContext, analyser, dataArray;
        let isBlowingMouth = false; // å˜´å‹åˆ¤å®š
        let isBlowingMic = false;   // è²éŸ³åˆ¤å®š
        let micVolume = 0;
        
        // äº’å‹•å°„ç·š (Raycaster)
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        async function initExperience() {
            const startScreen = document.getElementById('start-screen');
            const instructions = document.getElementById('instructions');
            const micIndicator = document.getElementById('mic-indicator');
            const btn = document.getElementById('btn-start');

            btn.innerText = "å•Ÿå‹•ä¸­...";
            
            try {
                // 1. å–å¾—å½±éŸ³æ¬Šé™ (ç›¸æ©Ÿ + éº¥å…‹é¢¨)
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'user', width: 640, height: 480 }, 
                    audio: true 
                });

                // 2. è¨­å®šç›¸æ©Ÿ
                const video = document.getElementById('input-video');
                video.srcObject = stream;
                await video.play();

                // 3. è¨­å®šéŸ³è¨Šåˆ†æ (Audio Context)
                setupAudio(stream);

                // 4. åˆå§‹åŒ– 3D å ´æ™¯
                initThreeJS();

                // 5. åˆå§‹åŒ– AI
                initAI(video);

                // 6. UI åˆ‡æ›
                startScreen.style.display = 'none';
                instructions.style.opacity = 1;
                micIndicator.style.opacity = 1;

                // 7. åŠ å…¥é»æ“Šåµæ¸¬
                window.addEventListener('pointerdown', onPointerDown);

            } catch (err) {
                alert("å•Ÿå‹•å¤±æ•—: " + err.message + "\nè«‹ç¢ºèªå·²å…è¨±éº¥å…‹é¢¨èˆ‡ç›¸æ©Ÿæ¬Šé™");
                btn.innerText = "é‡è©¦";
            }
        }

        // --- éŸ³è¨Šè™•ç† ---
        function setupAudio(stream) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaStreamSource(stream);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            source.connect(analyser); // åªé€£æ¥åˆ†æå™¨ï¼Œä¸è¼¸å‡ºåˆ°å–‡å­ (é¿å…å›éŸ³)
            dataArray = new Uint8Array(analyser.frequencyBinCount);
        }

        function updateMic() {
            if (!analyser) return;
            analyser.getByteFrequencyData(dataArray);
            
            // è¨ˆç®—å¹³å‡éŸ³é‡
            let sum = 0;
            for(let i = 0; i < dataArray.length; i++) sum += dataArray[i];
            micVolume = sum / dataArray.length;

            // è¦–è¦ºå›é¥‹
            const levelBar = document.getElementById('mic-level');
            levelBar.style.width = Math.min(micVolume, 100) + '%';
            
            // åˆ¤å®šæ˜¯å¦åœ¨å¹æ°£ (éŸ³é‡é–¥å€¼å¯èª¿æ•´)
            isBlowingMic = micVolume > 20; 
        }

        // --- é»æ“Šçˆ†ç ´ (Raycasting) ---
        function onPointerDown(event) {
            // å°‡æ»‘é¼ /è§¸æ§åº§æ¨™è½‰ç‚ºæ¨™æº–åŒ–è¨­å‚™åº§æ¨™ (-1 åˆ° +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // æª¢æŸ¥æ˜¯å¦é»åˆ°æ³¡æ³¡
            // æ³¨æ„ï¼šæˆ‘å€‘åªåµæ¸¬æ³¡æ³¡çš„ Mesh
            const bubbleMeshes = bubbles.map(b => b.mesh);
            const intersects = raycaster.intersectObjects(bubbleMeshes);

            if (intersects.length > 0) {
                // æ‰¾åˆ°è¢«é»æ“Šçš„é‚£å€‹æ³¡æ³¡ç‰©ä»¶
                const hitMesh = intersects[0].object;
                
                // å¾ bubbles é™£åˆ—ä¸­åæŸ¥ä¸¦å¼•ç™¼çˆ†ç ´
                const targetBubble = bubbles.find(b => b.mesh === hitMesh);
                if (targetBubble) {
                    targetBubble.pop();
                }
            }
        }

        // --- 3D å ´æ™¯é‚è¼¯ ---
        function initThreeJS() {
            scene = new THREE.Scene();
            
            // å¤©ç©ºèƒŒæ™¯
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createLinearGradient(0, 0, 0, 32);
            gradient.addColorStop(0, '#87CEEB'); 
            gradient.addColorStop(1, '#E0F7FA'); 
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            scene.background = new THREE.CanvasTexture(canvas);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // ç‡ˆå…‰
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            animate();
        }

        // --- æ³¡æ³¡é¡åˆ¥ ---
        const bubbleGeo = new THREE.SphereGeometry(1, 64, 64);
        const bubbleMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, transmission: 0.95, opacity: 1, transparent: true,
            roughness: 0, metalness: 0, thickness: 0.1, 
            ior: 1.5, reflectivity: 1, clearcoat: 1, clearcoatRoughness: 0
        });

        class Bubble {
            constructor() {
                this.mesh = new THREE.Mesh(bubbleGeo, bubbleMat.clone()); // è¤‡è£½æè³ªä»¥ä¾¿ç¨ç«‹æ§åˆ¶
                
                const size = 0.2 + Math.random() * 0.3;
                this.mesh.scale.set(size, size, size);
                
                // å¾ç•«é¢åº•éƒ¨ä¸­å¤®ç”Ÿæˆ
                this.mesh.position.set((Math.random()-0.5)*0.5, -2, 0);
                
                this.speedY = 0.02 + Math.random() * 0.02;
                this.wobbleOffset = Math.random() * 100;
                this.isPopping = false;
                
                scene.add(this.mesh);
            }

            update() {
                if (this.isPopping) {
                    // çˆ†ç ´å‹•ç•«ï¼šå¿«é€Ÿè®Šå¤§ä¸¦æ¶ˆå¤±
                    this.mesh.scale.multiplyScalar(1.1);
                    this.mesh.material.opacity -= 0.1;
                    return (this.mesh.material.opacity > 0);
                }

                // ç‰©ç†ç§»å‹•
                // é¢¨é€Ÿå½±éŸ¿ (éŸ³é‡è¶Šå¤§ï¼Œé¢¨è¶Šå¼·)
                const windForce = (micVolume / 100) * 0.05; 
                this.mesh.position.y += this.speedY + windForce; 
                this.mesh.position.x += Math.sin(Date.now()*0.001 + this.wobbleOffset) * 0.01;

                // ç§»é™¤æ¢ä»¶
                if (this.mesh.position.y > 6) return false;
                return true;
            }

            pop() {
                if (this.isPopping) return;
                this.isPopping = true;
                // å¯ä»¥åœ¨é€™è£¡åŠ å…¥éŸ³æ•ˆé‚è¼¯
            }

            dispose() {
                scene.remove(this.mesh);
                this.mesh.geometry.dispose(); // æ³¨æ„ï¼šå¹¾ä½•é«”æ˜¯å…±ç”¨çš„ï¼Œå…¶å¯¦ä¸ç”¨ dispose
                this.mesh.material.dispose();
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            updateMic(); // æ›´æ–°éŸ³é‡

            // ç”Ÿæˆæ³¡æ³¡é‚è¼¯ï¼š(å˜´å‹ç¬¦åˆ OR è²éŸ³å¤ å¤§) AND æ©Ÿç‡
            const shouldSpawn = (isBlowingMouth || isBlowingMic) && Math.random() > 0.85;
            
            if (shouldSpawn) {
                bubbles.push(new Bubble());
            }

            // æ›´æ–°æ‰€æœ‰æ³¡æ³¡
            for (let i = bubbles.length - 1; i >= 0; i--) {
                if (!bubbles[i].update()) {
                    bubbles[i].dispose();
                    bubbles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        // --- AI æ¨¡å‹ ---
        function initAI(videoElement) {
            const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
            faceMesh.setOptions({maxNumFaces: 1, minDetectionConfidence: 0.5});
            
            faceMesh.onResults((results) => {
                if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                    const lm = results.multiFaceLandmarks[0];
                    // å˜´å·´å¯¬é«˜æ¯”
                    const h = Math.hypot(lm[13].x - lm[14].x, lm[13].y - lm[14].y);
                    const w = Math.hypot(lm[61].x - lm[291].x, lm[61].y - lm[291].y);
                    
                    // åˆ¤å®šæ˜¯å¦å˜Ÿå˜´ (æ¯”å€¼ > 0.4 ä¸”å˜´å·´å¾®é–‹)
                    if ((h/w) > 0.4 && h > 0.01) {
                        isBlowingMouth = true;
                    } else {
                        isBlowingMouth = false;
                    }
                }
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await faceMesh.send({image: videoElement}); },
                width: 640, height: 480
            });
            cameraUtils.start();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
