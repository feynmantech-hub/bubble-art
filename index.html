<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D 吹泡泡互動藝術</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: "微軟正黑體", sans-serif; }
        canvas { display: block; }
        
        /* 介面容器 */
        #ui-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; pointer-events: none;
        }

        /* 按鈕設計 */
        #start-btn {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: white; padding: 15px 40px; font-size: 1.5rem;
            border-radius: 30px; cursor: pointer; backdrop-filter: blur(10px);
            transition: 0.3s;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        #start-btn:hover { background: rgba(255, 255, 255, 0.4); transform: scale(1.05); }
        
        #status-msg {
            margin-top: 20px; color: rgba(255,255,255,0.8); 
            text-align: center; font-size: 1rem; max-width: 80%;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px;
        }

        /* 隱藏的 Video */
        #camera-feed {
            position: absolute; bottom: 10px; right: 10px; width: 120px; height: 90px;
            border-radius: 8px; transform: scaleX(-1); opacity: 0.5; z-index: 10;
            object-fit: cover; display: none; 
        }

        /* 互動提示 */
        #instructions {
            position: absolute; top: 20px; width: 100%;
            text-align: center; color: rgba(255,255,255,0.9); pointer-events: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5); opacity: 0; transition: opacity 1s;
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <button id="start-btn">開始體驗</button>
        <div id="status-msg">請點擊按鈕啟動</div>
    </div>

    <div id="instructions">
        <h2>請對著鏡頭「嘟嘴」吹氣</h2>
        <p>泡泡會隨著微風飄動</p>
    </div>
    
    <video id="camera-feed" playsinline webkit-playsinline></video>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/face_mesh": "https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/index.js",
                "@mediapipe/camera_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FaceMesh } from '@mediapipe/face_mesh';
        import { Camera } from '@mediapipe/camera_utils';

        const startBtn = document.getElementById('start-btn');
        const statusMsg = document.getElementById('status-msg');
        const instructions = document.getElementById('instructions');
        const videoElement = document.getElementById('camera-feed');
        let cameraUtils;
        let isCameraStarted = false;

        // --- 1. 初始化 AI 模型 ---
        statusMsg.innerText = "正在載入 AI 模型...";
        startBtn.disabled = true; // 模型載入前先鎖住按鈕

        const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
        faceMesh.setOptions({
            maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5
        });
        
        faceMesh.onResults(onResults);
        
        // 當 FaceMesh 準備好後，解鎖按鈕
        faceMesh.initialize().then(() => {
            statusMsg.innerText = "準備就緒，請點擊按鈕";
            startBtn.disabled = false;
        });

        // --- 2. 按鈕啟動邏輯 ---
        startBtn.addEventListener('click', async () => {
            startBtn.style.display = 'none';
            statusMsg.innerText = "正在請求相機權限...";
            
            try {
                // 初始化相機工具
                cameraUtils = new Camera(videoElement, {
                    onFrame: async () => { await faceMesh.send({image: videoElement}); },
                    width: 640, height: 480
                });
                
                await cameraUtils.start();
                
                // 成功啟動
                statusMsg.style.display = 'none';
                instructions.style.opacity = 1;
                videoElement.style.display = 'block';
                isCameraStarted = true;

            } catch (error) {
                console.error(error);
                statusMsg.style.color = "#ff6b6b";
                statusMsg.innerText = "錯誤：無法開啟鏡頭。\n請檢查瀏覽器網址列是否封鎖了權限，\n或嘗試使用其他瀏覽器。";
                startBtn.style.display = 'block';
                startBtn.innerText = "重試";
            }
        });

        // --- 3. Three.js 場景 ---
        const scene = new THREE.Scene();
        // 背景漸層
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const context = canvas.getContext('2d');
        const gradient = context.createLinearGradient(0, 0, 0, 32);
        gradient.addColorStop(0, '#87CEEB'); 
        gradient.addColorStop(1, '#E0F7FA'); 
        context.fillStyle = gradient;
        context.fillRect(0, 0, 32, 32);
        scene.background = new THREE.CanvasTexture(canvas);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 3);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        // --- 泡泡物件 ---
        const bubbles = [];
        const bubbleGeometry = new THREE.SphereGeometry(1, 64, 64);
        const bubbleMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, metalness: 0.1, roughness: 0, transmission: 1, 
            thickness: 0.1, envMapIntensity: 1, iridescence: 1, 
            iridescenceIOR: 1.3, iridescenceThicknessRange: [100, 400],
            transparent: true, opacity: 1
        });

        let windVector = new THREE.Vector3(0, 0, 0);
        let time = 0;

        class Bubble {
            constructor() {
                const scale = 0.2 + Math.random() * 0.3;
                this.mesh = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
                this.mesh.scale.set(scale, scale, scale);
                this.mesh.position.set((Math.random() - 0.5) * 0.5, -1.5, 0);
                this.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.02,
                    0.05 + Math.random() * 0.05,
                    (Math.random() - 0.5) * 0.02
                );
                this.wobbleSpeed = Math.random() * 2 + 1;
                this.life = 1.0;
                scene.add(this.mesh);
            }
            update() {
                this.velocity.x += windVector.x * 0.002;
                this.velocity.y += windVector.y * 0.002;
                this.velocity.z += windVector.z * 0.002;
                this.mesh.position.add(this.velocity);
                this.velocity.multiplyScalar(0.99);
                this.velocity.y += 0.0005;
                const wobble = Math.sin(Date.now() * 0.005 * this.wobbleSpeed) * 0.05;
                this.mesh.scale.setScalar(this.mesh.scale.x + wobble * 0.01);
                this.life -= 0.002;
                if (this.life < 0.2) this.mesh.scale.multiplyScalar(0.95);
            }
            isDead() { return this.life <= 0 || this.mesh.position.y > 10; }
            dispose() { scene.remove(this.mesh); }
        }

        // --- 嘴型判斷 ---
        let isBlowing = false;
        function onResults(results) {
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                const topLip = landmarks[13]; 
                const bottomLip = landmarks[14];
                const leftCorner = landmarks[61];
                const rightCorner = landmarks[291];
                const width = Math.hypot(rightCorner.x - leftCorner.x, rightCorner.y - leftCorner.y);
                const height = Math.hypot(bottomLip.x - topLip.x, bottomLip.y - topLip.y);
                const ratio = height / width;
                
                // 判斷邏輯
                if (ratio > 0.6 && height > 0.01) {
                    isBlowing = true;
                } else {
                    isBlowing = false;
                }
            }
        }

        // --- 動畫 ---
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            // 風場
            const windX = Math.sin(time) * 0.5 + Math.sin(time * 0.3) * 0.3;
            const windZ = Math.cos(time * 0.8) * 0.2;
            windVector.set(windX, 0, windZ);

            if (isBlowing && Math.random() > 0.8) bubbles.push(new Bubble());

            for (let i = bubbles.length - 1; i >= 0; i--) {
                const b = bubbles[i];
                b.update();
                if (b.isDead()) { b.dispose(); bubbles.splice(i, 1); }
            }
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
