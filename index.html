<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D æ³¡æ³¡ (ImportMap ä¿®å¾©ç‰ˆ)</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <style>
        /* å¼·åˆ¶è¨­å®šèƒŒæ™¯ï¼Œé¿å…ç™½ç•«é¢ */
        html, body {
            margin: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #2b1055 0%, #7597de 100%) !important;
            font-family: "Microsoft JhengHei", sans-serif;
            color: white;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* é™¤éŒ¯è¨Šæ¯çª— */
        #error-log {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 150px;
            background: rgba(0, 0, 0, 0.8);
            color: #ff5555;
            font-family: monospace;
            font-size: 12px;
            overflow-y: scroll;
            z-index: 9999;
            padding: 10px;
            pointer-events: none; 
            display: block;
        }

        /* å•Ÿå‹•ç•«é¢ */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            text-align: center;
        }

        button {
            padding: 15px 30px;
            font-size: 1.2rem;
            margin: 10px;
            border-radius: 50px;
            border: none;
            cursor: pointer;
            transition: 0.2s;
        }

        button:disabled {
            background-color: #555;
            color: #888;
            cursor: not-allowed;
        }

        #btn-camera { background: #fd79a8; color: white; }
        #btn-mouse { background: #0984e3; color: white; }

        #status-text {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: 10;
            font-size: 1.2rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
        }
        
        .input_video { display: none; }
    </style>
</head>
<body>

    <div id="error-log">ç³»çµ±æ—¥èªŒ:<br></div>

    <div id="status-text">ç­‰å¾…é¸æ“‡æ¨¡å¼...</div>

    <div id="start-screen">
        <h1>ğŸ«§ 3D æ³¡æ³¡å¯¦é©—å®¤</h1>
        <p id="loading-hint">æ­£åœ¨ä¸‹è¼‰ AI æ¨¡å‹ï¼Œè«‹ç¨å€™...</p>
        
        <div id="btn-container" style="display:none;">
            <button id="btn-camera">ğŸ“¸ é–‹å•Ÿç›¸æ©Ÿå¹æ°£</button>
            <button id="btn-mouse">ğŸ–±ï¸ æ»‘é¼ æ¨¡å¼ (æ¸¬è©¦ç”¨)</button>
        </div>
        <br>
        <p style="font-size: 0.8rem; color:#aaa;">å¦‚æœç›¸æ©Ÿæ²’åæ‡‰ï¼Œè«‹æ”¹ç”¨æ»‘é¼ æ¨¡å¼</p>
    </div>

    <video class="input_video" playsinline></video>

    <script>
        const logBox = document.getElementById('error-log');
        function screenLog(msg, color='#0f0') {
            const div = document.createElement('div');
            div.innerText = `> ${msg}`;
            div.style.color = color;
            logBox.appendChild(div);
            logBox.scrollTop = logBox.scrollHeight;
            console.log(msg);
        }
        
        window.onerror = function(message, source, lineno, colno, error) {
            screenLog(`éŒ¯èª¤: ${message} (Line: ${lineno})`, '#ff3333');
            return false;
        };

        screenLog("é é¢è¼‰å…¥ä¸­...");
        
        window.onload = function() {
            screenLog("Window Loaded.");
            if(typeof FaceMesh === 'undefined') {
                screenLog("è­¦å‘Š: FaceMesh å°šæœªè¼‰å…¥ï¼Œè«‹æª¢æŸ¥ç¶²è·¯", 'yellow');
            } else {
                screenLog("AI æ¨¡å‹åº«è¼‰å…¥å®Œæˆ", '#00ffff');
                document.getElementById('loading-hint').style.display = 'none';
                document.getElementById('btn-container').style.display = 'block';
            }
        };
    </script>

    <script type="module">
        // ã€ä¿®æ­£ã€‘ä½¿ç”¨ import map å®šç¾©çš„åç¨±ä¾†å¼•å…¥ï¼Œé€™æ¨£å°±ä¸æœƒå ±éŒ¯äº†
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        screenLog("Three.js æ¨¡çµ„è¼‰å…¥æˆåŠŸ");

        // --- è®Šæ•¸ ---
        let scene, camera, renderer, controls;
        let bubbles = [];
        let isBlowing = false;
        let blowDirection = 0;
        let mode = 'none';
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();

        // --- 3D åˆå§‹åŒ– ---
        function initThree() {
            try {
                screenLog("åˆå§‹åŒ– 3D å ´æ™¯...");
                const container = document.body;
                
                scene = new THREE.Scene();
                
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 0, 20);

                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                container.appendChild(renderer.domElement);

                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.minDistance = 5;
                controls.maxDistance = 50;

                // ç‡ˆå…‰
                scene.add(new THREE.AmbientLight(0xffffff, 0.6));
                const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
                dirLight.position.set(10, 20, 10);
                scene.add(dirLight);

                // è¨»å†Šäº‹ä»¶
                window.addEventListener('resize', onWindowResize);
                window.addEventListener('pointerdown', onPointerDown);
                
                // æ»‘é¼ æ¨¡æ“¬å¹æ°£
                window.addEventListener('pointermove', (e) => {
                    if (mode === 'mouse') {
                        if (e.buttons > 0) {
                            isBlowing = true;
                            blowDirection = (e.clientX / window.innerWidth - 0.5) * 8;
                            document.getElementById('status-text').innerText = "ğŸŒ¬ï¸ å¹æ°£ä¸­ (æ–¹å‘: " + blowDirection.toFixed(1) + ")";
                        } else {
                            isBlowing = false;
                            document.getElementById('status-text').innerText = "ğŸ‘† æŒ‰ä½æ»‘é¼ /è¢å¹•ä¾†å¹æ°£";
                        }
                    }
                });

                screenLog("3D å ´æ™¯å»ºç«‹å®Œæˆ");
                animate();

            } catch (e) {
                screenLog("3D åˆå§‹åŒ–å¤±æ•—: " + e.message, 'red');
            }
        }

        // --- æ³¡æ³¡ç›¸é—œ ---
        const geometry = new THREE.SphereGeometry(1, 64, 64);
        const material = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            transmission: 1,
            opacity: 1,
            roughness: 0,
            ior: 1.5,
            thickness: 0.1,
            iridescence: 1,
            iridescenceIOR: 1.3,
            clearcoat: 1
        });

        function createBubble() {
            const bubble = new THREE.Mesh(geometry, material.clone());
            bubble.position.set((Math.random()-0.5)*2, -8, 5);
            const s = 0.8 + Math.random();
            bubble.scale.set(s,s,s);
            scene.add(bubble);

            const speedX = blowDirection * 0.3 + (Math.random()-0.5)*0.2;
            bubbles.push({
                mesh: bubble,
                velocity: new THREE.Vector3(speedX, 0.1 + Math.random()*0.1, -0.1)
            });
        }

        function onPointerDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(bubbles.map(b => b.mesh));
            if (hits.length > 0) {
                const target = hits[0].object;
                scene.remove(target);
                bubbles = bubbles.filter(b => b.mesh !== target);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if(controls) controls.update();

            if (isBlowing && Math.random() > 0.85) createBubble();

            for (let i = bubbles.length - 1; i >= 0; i--) {
                const b = bubbles[i];
                b.mesh.position.add(b.velocity);
                b.mesh.position.y += Math.sin(Date.now()*0.001 + b.mesh.id)*0.01;
                
                if (b.mesh.position.y > 30) {
                    scene.remove(b.mesh);
                    bubbles.splice(i, 1);
                }
            }
            if(renderer && scene && camera) renderer.render(scene, camera);
        }

        // --- æŒ‰éˆ•é‚è¼¯ ---
        document.getElementById('btn-mouse').addEventListener('click', () => {
            document.getElementById('start-screen').style.display = 'none';
            mode = 'mouse';
            initThree();
            document.getElementById('status-text').innerText = "ğŸ‘† æŒ‰ä½æ»‘é¼ /è¢å¹•ä¾†å¹æ°£";
        });

        document.getElementById('btn-camera').addEventListener('click', async () => {
            document.getElementById('start-screen').style.display = 'none';
            mode = 'camera';
            initThree();
            document.getElementById('status-text').innerText = "ğŸ“¸ æ­£åœ¨å•Ÿå‹•ç›¸æ©Ÿ...";
            screenLog("å˜—è©¦å•Ÿå‹•ç›¸æ©Ÿ...");

            try {
                const videoElement = document.getElementsByClassName('input_video')[0];
                const faceMesh = new FaceMesh({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                }});
                
                faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                faceMesh.onResults((results) => {
                    if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                        const lm = results.multiFaceLandmarks[0];
                        
                        const h = Math.hypot(lm[13].x - lm[14].x, lm[13].y - lm[14].y);
                        const w = Math.hypot(lm[61].x - lm[291].x, lm[61].y - lm[291].y);
                        const ratio = h / w;

                        const faceX = lm[1].x;
                        blowDirection = (0.5 - faceX) * 8; 

                        if (ratio > 0.5 && h > 0.01) {
                            isBlowing = true;
                            document.getElementById('status-text').innerText = "ğŸŒ¬ï¸ å¹æ°£ä¸­!";
                            document.getElementById('status-text').style.color = "#aaffaa";
                        } else {
                            isBlowing = false;
                            document.getElementById('status-text').innerText = "ğŸ˜ è«‹å˜Ÿå˜´ (Oå‹)";
                            document.getElementById('status-text').style.color = "white";
                        }
                    }
                });

                const cameraUtils = new Camera(videoElement, {
                    onFrame: async () => {
                        await faceMesh.send({image: videoElement});
                    },
                    width: 640,
                    height: 480
                });
                
                await cameraUtils.start();
                screenLog("ç›¸æ©Ÿå•Ÿå‹•æˆåŠŸï¼");

            } catch (err) {
                screenLog("ç›¸æ©ŸéŒ¯èª¤: " + err.message, 'red');
                alert("ç›¸æ©Ÿç„¡æ³•å•Ÿå‹•ï¼Œè«‹ç¢ºèªç¶²å€æ˜¯ https é–‹é ­ã€‚");
            }
        });

    </script>
</body>
</html>
