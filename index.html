<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D æ³¡æ³¡ V7.1 (æ˜äº®å¤§æ³¡æ³¡)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: "å¾®è»Ÿæ­£é»‘é«”", sans-serif; user-select: none; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 100; pointer-events: none; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }

        #version-tag {
            position: absolute; top: 10px; right: 10px; color: #555; font-size: 12px;
        }

        #start-screen {
            pointer-events: auto; background: rgba(20,20,20,0.9);
            padding: 40px; border-radius: 20px; text-align: center;
            border: 1px solid #444; box-shadow: 0 0 50px rgba(255,200,0,0.3);
        }

        h1 {
            color: #fff; margin: 0 0 10px 0; font-size: 2rem;
            text-shadow: 0 0 10px #ffcc00;
        }

        #btn-start {
            background: linear-gradient(135deg, #ffaa00, #ffdd00); color: #000; border: none; padding: 15px 50px; font-size: 1.2rem;
            border-radius: 30px; cursor: pointer; margin-top: 20px; font-weight: bold;
            box-shadow: 0 0 20px rgba(255,170,0,0.5); transition: 0.2s;
        }
        #btn-start:hover { transform: scale(1.05); box-shadow: 0 0 30px rgba(255,170,0,0.8); }

        #instructions {
            position: absolute; top: 20px; width: 100%; text-align: center;
            opacity: 0; transition: opacity 1s; pointer-events: none;
            color: white; text-shadow: 0 2px 4px #000;
        }
        
        #wind-arrow {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 5rem; color: rgba(255,255,255,0.2); font-weight: bold;
            opacity: 0; transition: opacity 0.3s; pointer-events: none;
        }

        #mic-indicator {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 200px; height: 6px; background: #333;
            border-radius: 3px; overflow: hidden; opacity: 0; transition: opacity 1s;
        }
        #mic-level {
            width: 0%; height: 100%; background: linear-gradient(90deg, #ffaa00, #ffff00); transition: width 0.05s;
        }

        video { position: absolute; opacity: 0; pointer-events: none; }
    </style>

    <script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-layer">
        <div id="version-tag">V7.1 Bright & Big</div>
        <div id="wind-arrow">â¤</div>
        
        <div id="start-screen">
            <h1>âœ¨ æ˜äº®å¤§æ³¡æ³¡ç‰ˆ</h1>
            <p style="color:#aaa;">è«‹å˜—è©¦å·¦å³è½‰é ­å¹æ°£</p>
            <button id="btn-start" onclick="initExperience()">é–‹å•Ÿé«”é©—</button>
        </div>

        <div id="instructions">
            <div style="font-size: 1.3rem; font-weight: bold; margin-bottom:5px;">ğŸ˜® è©¦è‘—å¾€å³æˆ–å¾€å·¦å¹æ°£</div>
            <div style="font-size: 1rem; color: #ccc;">ğŸ‘† é»æ“Šå¤§æ³¡æ³¡æˆ³ç ´å®ƒ</div>
        </div>
        <div id="mic-indicator"><div id="mic-level"></div></div>
    </div>

    <video id="input-video" playsinline webkit-playsinline muted></video>

    <script>
        let scene, camera, renderer;
        let bubbles = [];
        let audioContext, analyser, dataArray;
        let isBlowingMouth = false, isBlowingMic = false, micVolume = 0;
        let windDirectionX = 0;
        let mouthPosition = new THREE.Vector3(0, -2, 0); 
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        async function initExperience() {
            const btn = document.getElementById('btn-start');
            btn.innerText = "æš–æ©Ÿä¸­...";
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: 640, height: 480 }, audio: true });
                document.getElementById('input-video').srcObject = stream;
                document.getElementById('input-video').play();
                setupAudio(stream);
                initThreeJS(); 
                initAI(document.getElementById('input-video'));
                
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('instructions').style.opacity = 1;
                document.getElementById('mic-indicator').style.opacity = 1;
                window.addEventListener('pointerdown', onPointerDown);
            } catch (err) {
                alert("éŒ¯èª¤: " + err.message);
                btn.innerText = "é‡è©¦";
            }
        }

        function setupAudio(stream) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaStreamSource(stream);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            source.connect(analyser);
            dataArray = new Uint8Array(analyser.frequencyBinCount);
        }

        function updateMic() {
            if (!analyser) return;
            analyser.getByteFrequencyData(dataArray);
            let sum = 0;
            for(let i = 0; i < dataArray.length; i++) sum += dataArray[i];
            micVolume = sum / dataArray.length;
            document.getElementById('mic-level').style.width = Math.min(micVolume*1.5, 100) + '%';
            isBlowingMic = micVolume > 15; 
        }

        function onPointerDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(bubbles.map(b => b.mesh));
            if (intersects.length > 0) {
                const targetBubble = bubbles.find(b => b.mesh === intersects[0].object);
                if (targetBubble) targetBubble.pop();
            }
        }

        // --- æè³ª ---
        const bubbleGeo = new THREE.SphereGeometry(1, 64, 64);
        let bubbleMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, 
            transmission: 1.0,  
            opacity: 1.0,
            transparent: true,
            roughness: 0.0,
            metalness: 0.1,
            thickness: 0.1, 
            ior: 1.5,
            reflectivity: 1,
            iridescence: 1.0,
            iridescenceIOR: 1.33,
            iridescenceThicknessRange: [100, 800],
            clearcoat: 1.0,
            clearcoatRoughness: 0
        });

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // ç´”é»‘èƒŒæ™¯

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2; // ç¨å¾®å¢åŠ æ•´é«”æ›å…‰
            document.body.appendChild(renderer.domElement);

            // --- V7.1 ç‡ˆå…‰å¢å¼· ---
            
            // 1. ç’°å¢ƒå…‰ï¼šå¢å¼·ï¼Œè®“æš—éƒ¨æœ‰ç´°ç¯€
            scene.add(new THREE.AmbientLight(0xffffff, 0.6)); 

            // 2. ä¸»è§’é»å…‰æº (å³å´)ï¼šå¤§å¹…å¢å¼·äº®åº¦
            const pointLight = new THREE.PointLight(0xffaa00, 15, 100); 
            pointLight.position.set(10, 2, 5);
            scene.add(pointLight);

            // 3. è¼ªå»“å…‰ (å·¦å¾Œ)ï¼šå¢å¼·
            const rimLight = new THREE.DirectionalLight(0x4444ff, 5); 
            rimLight.position.set(-5, 0, -5);
            scene.add(rimLight);

            animate();
        }

        class Bubble {
            constructor() {
                this.mesh = new THREE.Mesh(bubbleGeo, bubbleMat);
                
                // --- V7.1 æ³¡æ³¡è®Šå¤§ ---
                // èˆŠç‰ˆç´„ 0.2~0.5ï¼Œæ–°ç‰ˆç´„ 0.6~1.2
                const size = 0.6 + Math.random() * 0.6;
                this.mesh.scale.set(size, size, size);
                
                // ç”Ÿæˆä½ç½®ï¼šè·Ÿéš¨å˜´å·´
                const startX = mouthPosition.x * 3; 
                const startY = mouthPosition.y * 3;
                this.mesh.position.set(startX + (Math.random()-0.5)*0.2, startY, 0);
                
                // åˆå§‹é€Ÿåº¦ï¼šå—é¢¨å‘å½±éŸ¿
                const windForce = windDirectionX * 0.08;
                
                this.velocity = new THREE.Vector3(
                    windForce + (Math.random()-0.5)*0.01, 
                    0.03 + Math.random() * 0.02,          
                    (Math.random()-0.5)*0.01              
                );

                this.wobbleOffset = Math.random() * 100;
                this.isPopping = false;
                this.popScale = 1.0;
                scene.add(this.mesh);
            }

            update() {
                if (this.isPopping) {
                    this.popScale *= 1.2;
                    this.mesh.scale.setScalar(this.popScale * this.mesh.scale.x);
                    if(this.popScale > 5) return false;
                    return true;
                }

                // é¢¨åŠ›èˆ‡è²éŸ³æ¨åŠ›
                const boost = (micVolume / 100) * 0.005;
                this.velocity.y += boost;
                this.velocity.x += windDirectionX * 0.002; 

                this.mesh.position.add(this.velocity);
                this.velocity.multiplyScalar(0.98); 
                this.velocity.y += 0.0005; // æµ®åŠ›

                const wobble = Math.sin(Date.now()*0.005 + this.wobbleOffset)*0.05;
                this.mesh.scale.setScalar(this.mesh.scale.x + wobble*0.002);
                
                // æ“´å¤§ç§»é™¤é‚Šç•Œï¼Œå› ç‚ºæ³¡æ³¡è®Šå¤§äº†
                return (this.mesh.position.y < 7 && Math.abs(this.mesh.position.x) < 10);
            }
            pop() { if(!this.isPopping) this.isPopping = true; }
            dispose() { scene.remove(this.mesh); }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateMic();
            
            // è¦–è¦ºåŒ–ç®­é ­æ›´æ–°
            const arrow = document.getElementById('wind-arrow');
            if (Math.abs(windDirectionX) > 0.25) {
                arrow.style.opacity = 0.6;
                arrow.innerText = windDirectionX > 0 ? "â¤" : "â—„";
                arrow.style.transform = `translate(-50%, -50%) translateX(${windDirectionX * 60}px)`;
            } else {
                arrow.style.opacity = 0;
            }

            if ((isBlowingMouth || isBlowingMic) && Math.random() > 0.85) bubbles.push(new Bubble());
            
            for (let i = bubbles.length - 1; i >= 0; i--) {
                if (!bubbles[i].update()) { bubbles[i].dispose(); bubbles.splice(i, 1); }
            }
            renderer.render(scene, camera);
        }

        function initAI(videoElement) {
            const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
            faceMesh.setOptions({maxNumFaces: 1, minDetectionConfidence: 0.5});
            
            faceMesh.onResults((results) => {
                if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                    const lm = results.multiFaceLandmarks[0];

                    // å˜´å‹
                    const mouthH = Math.hypot(lm[13].x - lm[14].x, lm[13].y - lm[14].y);
                    const mouthW = Math.hypot(lm[61].x - lm[291].x, lm[61].y - lm[291].y);
                    isBlowingMouth = ((mouthH/mouthW) > 0.35 && mouthH > 0.01);

                    // é ­éƒ¨æ–¹å‘
                    const leftFaceZ = lm[454].z;
                    const rightFaceZ = lm[234].z;
                    const yaw = (leftFaceZ - rightFaceZ) * 10; 
                    windDirectionX += (yaw - windDirectionX) * 0.1;

                    // å˜´å·´ä½ç½®
                    const mouthX = -(lm[13].x - 0.5) * 2; 
                    const mouthY = -(lm[13].y - 0.5) * 2; 
                    mouthPosition.set(mouthX, mouthY, 0);
                }
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await faceMesh.send({image: videoElement}); }, width: 640, height: 480
            });
            cameraUtils.start();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
