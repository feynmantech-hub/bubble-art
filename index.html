<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D æ³¡æ³¡ (V13.0 çµ‚æ¥µè—è¡“ç‰ˆ)</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>

    <style>
        html, body {
            margin: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            /* æ¥µæ·±è‰²èƒŒæ™¯ï¼Œå°æ¯”åº¦æœ€å¤§åŒ– */
            background: linear-gradient(180deg, #02020a 0%, #101530 100%) !important;
            font-family: "Microsoft JhengHei", sans-serif;
            color: white;
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 50;
            pointer-events: none;
        }
        #status-main {
            font-size: 1.5rem;
            font-weight: bold;
            text-shadow: 0 2px 10px rgba(0,0,0,1);
        }
        #status-debug {
            font-size: 0.9rem;
            color: #ccc;
            background: rgba(0,0,0,0.6);
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            margin-top: 5px;
            backdrop-filter: blur(4px);
        }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.98);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        button {
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 50px;
            border: none;
            cursor: pointer;
            background: linear-gradient(45deg, #ff00cc, #3333ff);
            color: white; 
            font-weight: bold;
            box-shadow: 0 0 30px rgba(255, 0, 204, 0.5);
            transition: 0.3s;
        }
        button:active { transform: scale(0.95); box-shadow: 0 0 10px rgba(255, 0, 204, 0.8); }

        .input_video { 
            position: fixed; top: -10000px; left: -10000px;
            width: 640px; height: 480px; visibility: hidden;
        }
        
        #error-log {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30px;
            background: rgba(0,0,0,0.9);
            color: #00ff00;
            font-size: 11px;
            line-height: 30px;
            overflow: hidden;
            pointer-events: none;
            padding: 0 10px;
            white-space: nowrap;
        }
    </style>
</head>
<body>

    <div id="hud">
        <div id="status-main">ç­‰å¾…å•Ÿå‹•...</div>
        <div id="status-debug">æ•¸å€¼ç›£æ¸¬ (ç›®æ¨™ > 0.1)</div>
    </div>

    <div id="start-screen">
        <h1 style="color:white; margin-bottom:10px; text-shadow: 0 0 20px #ff00cc;">ğŸ«§ 3D æ³¡æ³¡ V13.0</h1>
        <p style="color:#aaa; font-size:0.9rem;">çµ‚æ¥µè—è¡“ç‰ˆ (æ•ˆæœæœ€å¤§åŒ–)</p>
        <br>
        <button id="btn-start" disabled>æ­£åœ¨è¼‰å…¥ AI...</button>
    </div>

    <video class="input_video" playsinline webkit-playsinline muted autoplay></video>
    <div id="error-log"></div>

    <script>
        const logBox = document.getElementById('error-log');
        function log(msg) { logBox.innerText = `> ${msg}`; }
        window.onerror = (msg) => log("éŒ¯èª¤: " + msg);
        window.onload = function() {
            if(window.FaceMesh && window.Camera) {
                const btn = document.getElementById('btn-start');
                btn.innerText = "ğŸ“¸ å•Ÿå‹•ç›¸æ©Ÿ";
                btn.disabled = false;
            } else {
                log("AI è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯");
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'https://esm.sh/three@0.160.0';
        import { OrbitControls } from 'https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js';
        import { RoomEnvironment } from 'https://esm.sh/three@0.160.0/examples/jsm/environments/RoomEnvironment.js';

        let scene, camera, renderer, controls;
        let bubbles = [];
        let isBlowing = false;
        let blowDirection = 0;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        document.getElementById('btn-start').addEventListener('click', async () => {
            document.getElementById('start-screen').style.display = 'none';
            initThree();
            startCamera();
        });

        // --- ã€é—œéµä¿®æ”¹ã€‘ç”Ÿæˆé‡åŠ›æ¢¯åº¦ç´‹ç† (æ¨¡æ“¬çœŸå¯¦åšåº¦è®ŠåŒ–) ---
        function createGravityThicknessMap() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // å‚ç›´æ¼¸å±¤ï¼šä¸Šè–„(é»‘) -> ä¸‹åš(ç™½)
            // é€™æœƒç”¢ç”Ÿåƒåƒè€ƒåœ–é‚£æ¨£å¹³æ»‘ã€å¸¶ç‹€çš„å½©è™¹
            const grad = ctx.createLinearGradient(0, 0, 0, 512);
            grad.addColorStop(0, '#000000'); 
            grad.addColorStop(1, '#ffffff');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 512, 512);
            
            // åŠ å…¥æ¥µå°‘é‡çš„æ“¾å‹•ï¼Œé¿å…å¤ªæ­»æ¿
            for(let i=0; i<20; i++) {
                ctx.beginPath();
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const r = Math.random() * 50 + 10;
                const g = ctx.createRadialGradient(x, y, 0, x, y, r);
                g.addColorStop(0, `rgba(255,255,255, ${Math.random()*0.2})`);
                g.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = g;
                ctx.arc(x, y, r, 0, Math.PI*2);
                ctx.fill();
            }

            const texture = new THREE.CanvasTexture(canvas);
            // ä¸éœ€è¦é‡è¤‡åŒ…è£¹ï¼Œå› ç‚ºæˆ‘å€‘è¦çš„æ˜¯å¾ä¸Šåˆ°ä¸‹çš„å–®ä¸€è®ŠåŒ–
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            return texture;
        }

        // --- 1. åˆå§‹åŒ– 3D ---
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 20);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            // ä½¿ç”¨é›»å½±ç´šè‰²èª¿ï¼Œä¸¦æé«˜æ›å…‰ï¼Œè®“äº®éƒ¨éæ›ç”¢ç”Ÿå…‰æšˆæ„Ÿ
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.3; 
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.minDistance = 5;
            controls.maxDistance = 50;

            // ç”Ÿæˆé«˜å‹•æ…‹ç¯„åœç’°å¢ƒå…‰
            const environment = new RoomEnvironment(renderer);
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(environment).texture;

            // ã€é—œéµä¿®æ”¹ã€‘æˆ²åŠ‡æ€§ç‡ˆå…‰ä½ˆå±€
            // 1. å¼·çƒˆçš„ä¸»å…‰æº (è£½é€ éŠ³åˆ©ç™½é»)
            const mainLight = new THREE.DirectionalLight(0xffffff, 5.0);
            mainLight.position.set(10, 20, 10);
            scene.add(mainLight);
            
            // 2. è—è‰²é‚Šç·£å…‰ (è£½é€ å†·è‰²èª¿è¼ªå»“)
            const rimLightBlue = new THREE.PointLight(0x0088ff, 1000, 50);
            rimLightBlue.position.set(-15, 10, -10);
            scene.add(rimLightBlue);

            // 3. æš–è‰²è£œå…‰ (å¢åŠ è‰²å½©è±å¯Œåº¦)
            const fillLightWarm = new THREE.PointLight(0xffaa00, 500, 50);
            fillLightWarm.position.set(15, -10, 5);
            scene.add(fillLightWarm);
            
            // æ¥µä½çš„ç’°å¢ƒå…‰ï¼Œç¢ºä¿æš—éƒ¨å¤ æš—
            scene.add(new THREE.AmbientLight(0xffffff, 0.05));

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            window.addEventListener('pointerdown', (e) => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const hits = raycaster.intersectObjects(bubbles.map(b => b.mesh));
                if(hits.length > 0) {
                    scene.remove(hits[0].object);
                    bubbles = bubbles.filter(b => b.mesh !== hits[0].object);
                }
            });

            animate();
            log("3D å¼•æ“å·²å•Ÿå‹• (V13.0 çµ‚æ¥µè—è¡“æè³ª)");
        }

        // --- 2. æ³¡æ³¡æè³ª (åƒæ•¸æ¥µé™åŒ–) ---
        const thicknessMap = createGravityThicknessMap();
        
        const geo = new THREE.SphereGeometry(1, 128, 128);
        const mat = new THREE.MeshPhysicalMaterial({
            color: 0x000000, 
            transmission: 1,
            transparent: true, 
            opacity: 0.05, // å¹¾ä¹å®Œå…¨é€æ˜

            metalness: 0,
            roughness: 0, // çµ•å°å…‰æ»‘
            
            // ã€ä¿®æ”¹ã€‘æé«˜æŠ˜å°„ç‡ï¼Œå¢å¼·é‚Šç·£åå°„
            ior: 1.5, 
            thickness: 0.1,

            iridescence: 1, 
            iridescenceIOR: 1.33,
            // ã€ä¿®æ”¹ã€‘æ“´å¤§ç¯„åœï¼Œæ•æ‰å®Œæ•´å…‰è­œ
            iridescenceThicknessRange: [100, 1000], 
            // ã€ä¿®æ”¹ã€‘æ‡‰ç”¨æ–°çš„é‡åŠ›æ¢¯åº¦è²¼åœ–
            iridescenceThicknessMap: thicknessMap,
            
            clearcoat: 1,
            clearcoatRoughness: 0,
            // ã€ä¿®æ”¹ã€‘æ¥µé™ç’°å¢ƒåå°„å¼·åº¦
            envMapIntensity: 15.0, 
            side: THREE.DoubleSide
        });

        function createBubble() {
            const b = new THREE.Mesh(geo, mat.clone());
            b.position.set((Math.random()-0.5)*3, -6, 5);
            const s = 0.8 + Math.random() * 0.5;
            b.scale.set(s,s,s);
            
            // éš¨æ©Ÿæ—‹è½‰åˆå§‹è§’åº¦ï¼Œè®“å½©è™¹æ–¹å‘ä¸ä¸€æ¨£
            b.rotation.x = Math.random() * Math.PI;
            b.rotation.y = Math.random() * Math.PI;
            
            scene.add(b);

            const vx = blowDirection * 0.4 + (Math.random()-0.5)*0.2;
            bubbles.push({
                mesh: b,
                velocity: new THREE.Vector3(vx, 0.1 + Math.random()*0.1, -0.1)
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // è²¼åœ–è¼•å¾®æµå‹•
            thicknessMap.offset.y -= 0.001; 

            if(isBlowing && Math.random() > 0.6) { 
                createBubble();
            }

            for(let i=bubbles.length-1; i>=0; i--) {
                const b = bubbles[i];
                b.mesh.position.add(b.velocity);
                b.mesh.position.y += Math.sin(Date.now()*0.003 + b.mesh.id)*0.015;
                
                // ç·©æ…¢æ—‹è½‰å±•ç¤ºå½©è™¹è®ŠåŒ–
                b.mesh.rotation.x += 0.005;
                b.mesh.rotation.y += 0.005;

                if(b.mesh.position.y > 25) {
                    scene.remove(b.mesh);
                    bubbles.splice(i,1);
                }
            }
            renderer.render(scene, camera);
        }

        // --- 3. ç›¸æ©Ÿèˆ‡ AI (ç¶­æŒé«˜éˆæ•åº¦) ---
        async function startCamera() {
            const video = document.querySelector('.input_video');
            const hudMain = document.getElementById('status-main');
            const hudDebug = document.getElementById('status-debug');

            const faceMesh = new window.FaceMesh({locateFile: (file) => 
                `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
            
            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            faceMesh.onResults((res) => {
                if (res.multiFaceLandmarks && res.multiFaceLandmarks.length > 0) {
                    const lm = res.multiFaceLandmarks[0];
                    const h = Math.hypot(lm[13].x - lm[14].x, lm[13].y - lm[14].y);
                    const w = Math.hypot(lm[61].x - lm[291].x, lm[61].y - lm[291].y);
                    const ratio = h / w;
                    
                    blowDirection = (0.5 - lm[1].x) * 6;
                    hudDebug.innerText = `å˜´å‹æ•¸å€¼: ${ratio.toFixed(2)} (ç›®æ¨™ > 0.1)`;

                    if (ratio > 0.1 && h > 0.005) { 
                        isBlowing = true;
                        hudMain.innerText = "ğŸŒ¬ï¸ å¹æ°£ä¸­ï¼";
                        hudMain.style.color = "#00ffcc"; 
                        hudMain.style.textShadow = "0 0 20px #00ffcc, 0 0 40px #00ffcc";
                    } else {
                        isBlowing = false;
                        hudMain.innerText = "ğŸ˜ è«‹å˜Ÿå˜´ (Oå‹)";
                        hudMain.style.color = "white";
                        hudMain.style.textShadow = "0 2px 10px rgba(0,0,0,0.8)";
                    }
                } else {
                    hudMain.innerText = "ğŸ‘€ æ‰¾ä¸åˆ°è‡‰...";
                    hudMain.style.color = "#ff3333"; 
                }
            });

            const camera = new window.Camera(video, {
                onFrame: async () => await faceMesh.send({image: video}),
                width: 640, height: 480
            });
            await camera.start();
            log("ç›¸æ©Ÿå½±åƒåˆ†æä¸­...");
        }
    </script>
</body>
</html>
