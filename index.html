<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D æ³¡æ³¡ V7.3 (é»ƒæ˜é‚Šç•Œ)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: "å¾®è»Ÿæ­£é»‘é«”", sans-serif; user-select: none; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 100; pointer-events: none; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }

        #version-tag {
            position: absolute; top: 10px; right: 10px; color: rgba(255,255,255,0.5); font-size: 12px; font-weight: bold;
        }

        #start-screen {
            pointer-events: auto; background: rgba(60, 20, 0, 0.85); /* é»ƒæ˜è‰²èª¿ */
            padding: 50px; border-radius: 25px; text-align: center;
            border: 2px solid #ff7e5f; box-shadow: 0 0 80px rgba(255, 100, 50, 0.6);
            backdrop-filter: blur(10px);
        }

        h1 {
            color: #fff; margin: 0 0 15px 0; font-size: 2.5rem;
            text-shadow: 0 0 20px #ff7e5f;
        }

        #btn-start {
            background: linear-gradient(to right, #feb47b, #ff7e5f); color: #fff; border: none; padding: 20px 60px; font-size: 1.5rem;
            border-radius: 40px; cursor: pointer; margin-top: 30px; font-weight: bold;
            box-shadow: 0 10px 30px rgba(255, 126, 95, 0.6); transition: 0.2s;
        }
        #btn-start:hover { transform: scale(1.05); box-shadow: 0 15px 40px rgba(255, 126, 95, 0.8); }

        #instructions {
            position: absolute; top: 20px; width: 100%; text-align: center;
            opacity: 0; transition: opacity 1s; pointer-events: none;
            color: white; text-shadow: 0 2px 10px rgba(0,0,0,0.8);
        }
        
        #wind-arrow {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 8rem; color: rgba(255,255,255,0.4); font-weight: bold;
            opacity: 0; transition: opacity 0.3s; pointer-events: none;
        }

        #mic-indicator {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 300px; height: 10px; background: rgba(0,0,0,0.5);
            border-radius: 5px; overflow: hidden; opacity: 0; transition: opacity 1s;
        }
        #mic-level {
            width: 0%; height: 100%; background: linear-gradient(90deg, #feb47b, #ff7e5f); transition: width 0.05s;
        }

        video { position: absolute; opacity: 0; pointer-events: none; }
    </style>

    <script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-layer">
        <div id="version-tag">V7.3 Sunset Horizon</div>
        <div id="wind-arrow">â¤</div>
        
        <div id="start-screen">
            <h1>ğŸŒ‡ é»ƒæ˜å·¨å¤§æ³¡æ³¡</h1>
            <p style="color:#ddd; font-size: 1.2rem;">è«‹å˜—è©¦å·¦å³è½‰é ­å¹æ°£</p>
            <button id="btn-start" onclick="initExperience()">é–‹å•Ÿé«”é©—</button>
        </div>

        <div id="instructions">
            <div style="font-size: 1.8rem; font-weight: bold; margin-bottom:10px;">ğŸ˜® è©¦è‘—å¾€å³æˆ–å¾€å·¦å¹æ°£</div>
            <div style="font-size: 1.2rem; color: #eee;">ğŸ‘† é»æ“Šæ³¡æ³¡æˆ³ç ´å®ƒ</div>
        </div>
        <div id="mic-indicator"><div id="mic-level"></div></div>
    </div>

    <video id="input-video" playsinline webkit-playsinline muted></video>

    <script>
        let scene, camera, renderer;
        let bubbles = [];
        let audioContext, analyser, dataArray;
        let isBlowingMouth = false, isBlowingMic = false, micVolume = 0;
        let windDirectionX = 0;
        let mouthPosition = new THREE.Vector3(0, -3, 0); 
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        async function initExperience() {
            const btn = document.getElementById('btn-start');
            btn.innerText = "æš–æ©Ÿä¸­...";
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: 640, height: 480 }, audio: true });
                document.getElementById('input-video').srcObject = stream;
                document.getElementById('input-video').play();
                setupAudio(stream);
                initThreeJS(); 
                initAI(document.getElementById('input-video'));
                
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('instructions').style.opacity = 1;
                document.getElementById('mic-indicator').style.opacity = 1;
                window.addEventListener('pointerdown', onPointerDown);
            } catch (err) {
                alert("éŒ¯èª¤: " + err.message);
                btn.innerText = "é‡è©¦";
            }
        }

        function setupAudio(stream) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaStreamSource(stream);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            source.connect(analyser);
            dataArray = new Uint8Array(analyser.frequencyBinCount);
        }

        function updateMic() {
            if (!analyser) return;
            analyser.getByteFrequencyData(dataArray);
            let sum = 0;
            for(let i = 0; i < dataArray.length; i++) sum += dataArray[i];
            micVolume = sum / dataArray.length;
            document.getElementById('mic-level').style.width = Math.min(micVolume*1.2, 100) + '%';
            isBlowingMic = micVolume > 12; 
        }

        function onPointerDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            raycaster.params.Sphere.threshold = 0.5;

            const intersects = raycaster.intersectObjects(bubbles.map(b => b.mesh));
            if (intersects.length > 0) {
                const targetBubble = bubbles.find(b => b.mesh === intersects[0].object);
                if (targetBubble) targetBubble.pop();
            }
        }

        // --- æè³ª ---
        const bubbleGeo = new THREE.SphereGeometry(1, 64, 64);
        let bubbleMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, 
            transmission: 1.0,  
            opacity: 1.0,
            transparent: true,
            roughness: 0.0,
            metalness: 0.3, // å¢åŠ é‡‘å±¬æ„Ÿä»¥å¢å¼·åå°„
            thickness: 0.5, // å¢åŠ åšåº¦æ„Ÿ
            ior: 1.5,
            reflectivity: 1,
            iridescence: 1.5,
            iridescenceIOR: 1.33,
            iridescenceThicknessRange: [100, 800],
            clearcoat: 1.0,
            clearcoatRoughness: 0,
            envMapIntensity: 2.5 // å¼·åˆ¶å¢å¼·ç’°å¢ƒåå°„å¼·åº¦
        });

        function initThreeJS() {
            scene = new THREE.Scene();

            // --- V7.3 é—œéµä¿®æ”¹: å»ºç«‹é»ƒæ˜æ¼¸å±¤èƒŒæ™¯ ---
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const context = canvas.getContext('2d');
            // å»ºç«‹å¾ä¸Šåˆ°ä¸‹çš„æ¼¸å±¤: æ·±è—å¤œç©º -> ç´«è‰²éæ¸¡ -> æ©˜ç´…å¤•é™½ -> åœ°å¹³ç·š
            const gradient = context.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0.0, '#0B1026'); // é ‚éƒ¨æ·±è—
            gradient.addColorStop(0.5, '#4B2D5B'); // ä¸­é–“ç´«
            gradient.addColorStop(0.8, '#C85D46'); // å¤•é™½æ©˜ç´…
            gradient.addColorStop(1.0, '#FF9C7C'); // åº•éƒ¨äº®æ©˜
            context.fillStyle = gradient;
            context.fillRect(0, 0, 512, 512);
            
            const bgTexture = new THREE.CanvasTexture(canvas);
            bgTexture.mapping = THREE.EquirectangularReflectionMapping; // è¨­ç‚ºåå°„æ¨¡å¼

            // å°‡é€™å€‹æ¼¸å±¤åŒæ™‚è¨­ç‚ºèƒŒæ™¯å’Œç’°å¢ƒå…‰ç½©
            scene.background = bgTexture;
            scene.environment = bgTexture; // è®“æ³¡æ³¡åå°„é€™å€‹å¤©ç©ºï¼

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
            camera.position.z = 6; 

            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.8; 
            document.body.appendChild(renderer.domElement);

            // --- V7.3 ç‡ˆå…‰èª¿æ•´ (é…åˆé»ƒæ˜) ---
            
            // æš–è‰²ç’°å¢ƒå…‰
            scene.add(new THREE.AmbientLight(0xffccaa, 1.5)); 

            // ä¸»å…‰æºæ”¹ç‚ºæš–æ©˜è‰²ï¼Œæ¨¡æ“¬å¤•é™½
            const pointLight = new THREE.PointLight(0xff6600, 30, 300); 
            pointLight.position.set(15, 5, 10);
            scene.add(pointLight);

            // è¼ªå»“å…‰æ”¹ç‚ºæš–ç´«è‰²
            const rimLight = new THREE.DirectionalLight(0xaa66ff, 8); 
            rimLight.position.set(-10, 5, -5);
            scene.add(rimLight);
            
            // åº•éƒ¨è£œå…‰
            const bottomLight = new THREE.DirectionalLight(0xffaa88, 5);
            bottomLight.position.set(0, -10, 0);
            scene.add(bottomLight);

            animate();
        }

        class Bubble {
            constructor() {
                this.mesh = new THREE.Mesh(bubbleGeo, bubbleMat);
                const size = 1.5 + Math.random() * 1.5;
                this.mesh.scale.set(size, size, size);
                
                const startX = mouthPosition.x * 4; 
                const startY = mouthPosition.y * 4;
                this.mesh.position.set(startX + (Math.random()-0.5)*0.5, startY, 0);
                
                const windForce = windDirectionX * 0.1;
                
                this.velocity = new THREE.Vector3(
                    windForce + (Math.random()-0.5)*0.02, 
                    0.04 + Math.random() * 0.03,          
                    (Math.random()-0.5)*0.02              
                );

                this.wobbleOffset = Math.random() * 100;
                this.isPopping = false;
                this.popScale = 1.0;
                scene.add(this.mesh);
            }

            update() {
                if (this.isPopping) {
                    this.popScale *= 1.25;
                    this.mesh.scale.setScalar(this.popScale * this.mesh.scale.x);
                    if(this.popScale > 4) return false;
                    return true;
                }

                const boost = (micVolume / 100) * 0.01;
                this.velocity.y += boost;
                this.velocity.x += windDirectionX * 0.003; 

                this.mesh.position.add(this.velocity);
                this.velocity.multiplyScalar(0.985); 
                this.velocity.y += 0.0008; 

                const wobble = Math.sin(Date.now()*0.004 + this.wobbleOffset)*0.08;
                this.mesh.scale.setScalar(this.mesh.scale.x + wobble*0.005);
                
                return (this.mesh.position.y < 12 && Math.abs(this.mesh.position.x) < 15);
            }
            pop() { if(!this.isPopping) this.isPopping = true; }
            dispose() { scene.remove(this.mesh); }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateMic();
            
            const arrow = document.getElementById('wind-arrow');
            if (Math.abs(windDirectionX) > 0.2) {
                arrow.style.opacity = 0.7;
                arrow.innerText = windDirectionX > 0 ? "â¤" : "â—„";
                arrow.style.transform = `translate(-50%, -50%) translateX(${windDirectionX * 80}px)`;
            } else {
                arrow.style.opacity = 0;
            }

            if ((isBlowingMouth || isBlowingMic) && Math.random() > 0.88) bubbles.push(new Bubble());
            
            for (let i = bubbles.length - 1; i >= 0; i--) {
                if (!bubbles[i].update()) { bubbles[i].dispose(); bubbles.splice(i, 1); }
            }
            renderer.render(scene, camera);
        }

        function initAI(videoElement) {
            const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
            faceMesh.setOptions({maxNumFaces: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
            
            faceMesh.onResults((results) => {
                if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                    const lm = results.multiFaceLandmarks[0];

                    const mouthH = Math.hypot(lm[13].x - lm[14].x, lm[13].y - lm[14].y);
                    const mouthW = Math.hypot(lm[61].x - lm[291].x, lm[61].y - lm[291].y);
                    isBlowingMouth = ((mouthH/mouthW) > 0.3 && mouthH > 0.01);

                    const leftFaceZ = lm[454].z;
                    const rightFaceZ = lm[234].z;
                    const yaw = (leftFaceZ - rightFaceZ) * 12; 
                    windDirectionX += (yaw - windDirectionX) * 0.15;

                    const mouthX = -(lm[13].x - 0.5) * 2; 
                    const mouthY = -(lm[13].y - 0.5) * 2; 
                    mouthPosition.set(mouthX, mouthY, 0);
                }
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await faceMesh.send({image: videoElement}); }, width: 640, height: 480
            });
            cameraUtils.start();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
