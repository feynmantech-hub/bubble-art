<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D å¹æ³¡æ³¡äº’å‹•è—è¡“ (V5.1)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: "å¾®è»Ÿæ­£é»‘é«”", sans-serif; user-select: none; }
        
        /* ä»‹é¢å±¤ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 100; pointer-events: none; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }

        /* é–‹å§‹ç•«é¢ */
        #start-screen {
            pointer-events: auto; background: rgba(0,0,0,0.75);
            padding: 40px; border-radius: 20px; text-align: center;
            backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1);
        }
        #btn-start {
            background: linear-gradient(135deg, #ff9a44, #fc6076); /* æ”¹ç”¨æš–è‰²ç³»æŒ‰éˆ• */
            color: white; border: none; padding: 15px 40px; font-size: 1.5rem;
            border-radius: 30px; cursor: pointer; margin-top: 20px;
            box-shadow: 0 4px 15px rgba(252, 96, 118, 0.4); transition: transform 0.2s;
        }
        #btn-start:active { transform: scale(0.95); }

        /* æŒ‡å¼•æ–‡å­— */
        #instructions {
            position: absolute; top: 20px; width: 100%; text-align: center;
            opacity: 0; transition: opacity 1s; pointer-events: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8); color: white;
        }
        .hint-text { font-size: 1.2rem; margin: 5px; color: #fff; font-weight: bold; }
        .sub-hint { font-size: 0.9rem; color: rgba(255,255,255,0.7); }

        /* éº¥å…‹é¢¨éŸ³é‡æ¢ */
        #mic-indicator {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 200px; height: 8px; background: rgba(255,255,255,0.1);
            border-radius: 4px; overflow: hidden; opacity: 0; transition: opacity 1s;
        }
        #mic-level {
            width: 0%; height: 100%; background: linear-gradient(90deg, #00ff88, #00ccff); transition: width 0.05s;
        }

        video { position: absolute; opacity: 0; pointer-events: none; }
    </style>

    <script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-layer">
        <div id="start-screen">
            <h1 style="color:white; margin:0;">âœ¨ å¤¢å¹»æ³¡æ³¡è—è¡“</h1>
            <p style="color:#ccc;">éœ€è¦ç›¸æ©Ÿèˆ‡éº¥å…‹é¢¨æ¬Šé™</p>
            <button id="btn-start" onclick="initExperience()">é–‹å§‹é«”é©—</button>
        </div>
        <div id="instructions">
            <div class="hint-text">ğŸ˜® å°è‘—éº¥å…‹é¢¨ã€Œå˜Ÿå˜´ã€å¹æ°£</div>
            <div class="sub-hint">ğŸ‘† é»æ“Šæ³¡æ³¡å¯ä»¥æˆ³ç ´å®ƒ</div>
        </div>
        <div id="mic-indicator"><div id="mic-level"></div></div>
    </div>

    <video id="input-video" playsinline webkit-playsinline muted></video>

    <script>
        let scene, camera, renderer;
        let bubbles = [];
        let audioContext, analyser, dataArray;
        let isBlowingMouth = false, isBlowingMic = false, micVolume = 0;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        async function initExperience() {
            const btn = document.getElementById('btn-start');
            btn.innerText = "å•Ÿå‹•ä¸­...";
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: 640, height: 480 }, audio: true });
                document.getElementById('input-video').srcObject = stream;
                document.getElementById('input-video').play();
                setupAudio(stream);
                initThreeJS(); // å…ˆåˆå§‹åŒ– 3D æ‰èƒ½å»ºç«‹æè³ª
                initAI(document.getElementById('input-video'));
                
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('instructions').style.opacity = 1;
                document.getElementById('mic-indicator').style.opacity = 1;
                window.addEventListener('pointerdown', onPointerDown);
            } catch (err) {
                alert("å•Ÿå‹•å¤±æ•—ï¼Œè«‹æª¢æŸ¥æ¬Šé™è¨­å®šã€‚\néŒ¯èª¤: " + err.message);
                btn.innerText = "é‡è©¦";
            }
        }

        function setupAudio(stream) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaStreamSource(stream);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            source.connect(analyser);
            dataArray = new Uint8Array(analyser.frequencyBinCount);
        }

        function updateMic() {
            if (!analyser) return;
            analyser.getByteFrequencyData(dataArray);
            let sum = 0;
            for(let i = 0; i < dataArray.length; i++) sum += dataArray[i];
            micVolume = sum / dataArray.length;
            document.getElementById('mic-level').style.width = Math.min(micVolume*1.5, 100) + '%'; //ç¨å¾®æ”¾å¤§é¡¯ç¤º
            isBlowingMic = micVolume > 15; 
        }

        function onPointerDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(bubbles.map(b => b.mesh));
            if (intersects.length > 0) {
                const targetBubble = bubbles.find(b => b.mesh === intersects[0].object);
                if (targetBubble) targetBubble.pop();
            }
        }

        // --- æ ¸å¿ƒæè³ªå®šç¾© (ç§»åˆ°å…¨åŸŸä»¥ä¾¿åˆå§‹åŒ–å¾Œä¿®æ”¹) ---
        const bubbleGeo = new THREE.SphereGeometry(1, 64, 64);
        // ä½¿ç”¨ MeshPhysicalMaterial å¯¦ç¾çœŸå¯¦æ„Ÿ
        let bubbleMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, 
            transmission: 1,  // å®Œå…¨é€å…‰
            opacity: 1,
            transparent: true,
            roughness: 0,     // è¡¨é¢æ¥µè‡´å…‰æ»‘
            metalness: 0,
            thickness: 0.1,   // è–„å£æ•ˆæœ
            ior: 1.33,        // æ°´çš„æŠ˜å°„ç‡
            reflectivity: 1,  // é«˜åå°„
            iridescence: 1,   // é–‹å•Ÿè™¹å½© (è–„è†œå¹²æ¶‰)
            iridescenceIOR: 1.3, // è™¹å½©æŠ˜å°„ç‡
            iridescenceThicknessRange: [100, 400], // è–„è†œåšåº¦ç¯„åœ(å¥ˆç±³)ï¼Œç”¢ç”Ÿä¸åŒé¡è‰²
            envMapIntensity: 1.5 // ç’°å¢ƒåå°„å¼·åº¦
        });

        function initThreeJS() {
            scene = new THREE.Scene();
            
            // --- æ–°èƒŒæ™¯è¨­è¨ˆ: é­”å¹»é»ƒæ˜ ---
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512; // è§£æåº¦æé«˜ä¸€é»ï¼Œåå°„æ¯”è¼ƒå¥½çœ‹
            const context = canvas.getContext('2d');
            // å»ºç«‹å‚ç›´æ¼¸å±¤: æ·±è—ç´«è‰² -> å¤•é™½æ©˜ç´…
            const gradient = context.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, '#2c3e50'); // æ·±è—ç°
            gradient.addColorStop(0.5, '#4ca1af'); // éæ¸¡è—
            gradient.addColorStop(1, '#fd746c'); // å¤•é™½ç´…
            context.fillStyle = gradient;
            context.fillRect(0, 0, 512, 512);
            
            // å°‡ Canvas è½‰ç‚ºç´‹ç†
            const bgTexture = new THREE.CanvasTexture(canvas);
            bgTexture.mapping = THREE.EquirectangularReflectionMapping; // è¨­å®šç‚ºåå°„æ˜ å°„æ¨¡å¼

            // è¨­å®šå ´æ™¯èƒŒæ™¯
            scene.background = bgTexture;
            
            // --- é—œéµ: å°‡èƒŒæ™¯ç´‹ç†è¨­ç‚ºæ³¡æ³¡çš„ç’°å¢ƒåå°„è²¼åœ– ---
            bubbleMat.envMap = bgTexture;
            bubbleMat.needsUpdate = true;

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // é›»å½±æ„Ÿè‰²èª¿æ˜ å°„
            document.body.appendChild(renderer.domElement);

            // ç‡ˆå…‰
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const dirLight = new THREE.DirectionalLight(0xffffff, 2);
            dirLight.position.set(-5, 10, 5); // å…‰å¾å´é¢æ‰“éä¾†ï¼Œå¢åŠ ç«‹é«”æ„Ÿ
            scene.add(dirLight);

            animate();
        }

        class Bubble {
            constructor() {
                this.mesh = new THREE.Mesh(bubbleGeo, bubbleMat); // æ‰€æœ‰æ³¡æ³¡å…±ç”¨ä¸€å€‹æè³ªå¯¦é«”(æ•ˆèƒ½è¼ƒå¥½)
                const size = 0.2 + Math.random() * 0.35;
                this.mesh.scale.set(size, size, size);
                this.mesh.position.set((Math.random()-0.5)*0.6, -2.5, 0);
                this.speedY = 0.015 + Math.random() * 0.02;
                this.wobbleOffset = Math.random() * 100;
                this.isPopping = false;
                this.popScale = 1.0;
                scene.add(this.mesh);
            }
            update() {
                if (this.isPopping) {
                    this.popScale *= 1.15; // çˆ†ç ´æ™‚å¿«é€Ÿè®Šå¤§
                    this.mesh.scale.setScalar(this.popScale * this.mesh.scale.x);
                    // é€™è£¡ç„¡æ³•å–®ç¨èª¿æ•´é€æ˜åº¦ï¼Œå› ç‚ºå…±ç”¨æè³ªã€‚åˆ©ç”¨è®Šå¤§ç§»å‡ºç•«é¢ä¾†æ¨¡æ“¬æ¶ˆå¤±
                    return (this.popScale < 3);
                }
                // é¢¨é€Ÿå½±éŸ¿ (éŸ³é‡è¶Šå¤§ï¼Œä¸Šå‡è¶Šå¿«)
                const windForce = (micVolume / 100) * 0.08; 
                this.mesh.position.y += this.speedY + windForce; 
                // å·¦å³æ“ºå‹•
                this.mesh.position.x += Math.sin(Date.now()*0.0015 + this.wobbleOffset) * 0.01;
                // è¼•å¾®å½¢è®Š
                const wobble = Math.sin(Date.now()*0.003 + this.wobbleOffset)*0.05;
                this.mesh.scale.set(this.mesh.scale.x+wobble*0.01, this.mesh.scale.y-wobble*0.01, this.mesh.scale.z);
                
                return (this.mesh.position.y < 6);
            }
            pop() { 
                if(!this.isPopping) {
                    this.isPopping = true;
                    // è‹¥è¦ç¨ç«‹çˆ†ç ´é€æ˜åº¦ï¼Œéœ€åœ¨ constructor clone æè³ªï¼Œä½†è¼ƒè€—æ•ˆèƒ½
                }
            }
            dispose() { scene.remove(this.mesh); }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateMic();
            // ç¨å¾®é™ä½ç”Ÿæˆé »ç‡ï¼Œè®“ç•«é¢ä¸è¦å¤ªæ“ 
            if ((isBlowingMouth || isBlowingMic) && Math.random() > 0.88) bubbles.push(new Bubble());
            for (let i = bubbles.length - 1; i >= 0; i--) {
                if (!bubbles[i].update()) { bubbles[i].dispose(); bubbles.splice(i, 1); }
            }
            renderer.render(scene, camera);
        }

        function initAI(videoElement) {
            const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
            faceMesh.setOptions({maxNumFaces: 1, minDetectionConfidence: 0.5});
            faceMesh.onResults((results) => {
                if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                    const lm = results.multiFaceLandmarks[0];
                    const h = Math.hypot(lm[13].x - lm[14].x, lm[13].y - lm[14].y);
                    const w = Math.hypot(lm[61].x - lm[291].x, lm[61].y - lm[291].y);
                    isBlowingMouth = ((h/w) > 0.4 && h > 0.01);
                }
            });
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await faceMesh.send({image: videoElement}); }, width: 640, height: 480
            });
            cameraUtils.start();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
