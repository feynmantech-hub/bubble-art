<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D æ³¡æ³¡è—è¡“ V6.0 (æ·±ç©ºç‰ˆ)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: "å¾®è»Ÿæ­£é»‘é«”", sans-serif; user-select: none; }
        
        /* ä»‹é¢å±¤ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 100; pointer-events: none; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }

        /* ç‰ˆæœ¬æ¨™è¨˜ (è®“ä½ çŸ¥é“æ›´æ–°æˆåŠŸæ²’) */
        #version-tag {
            position: absolute; top: 10px; right: 10px; color: rgba(255,255,255,0.3); font-size: 12px;
        }

        #start-screen {
            pointer-events: auto; background: rgba(20,20,30,0.85);
            padding: 40px; border-radius: 20px; text-align: center;
            backdrop-filter: blur(15px); border: 1px solid rgba(255,255,255,0.15);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        h1 {
            background: linear-gradient(to right, #a18cd1, #fbc2eb);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            margin: 0 0 10px 0; font-size: 2rem;
        }

        #btn-start {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white; border: none; padding: 15px 50px; font-size: 1.2rem;
            border-radius: 30px; cursor: pointer; margin-top: 20px; font-weight: bold;
            box-shadow: 0 4px 15px rgba(118, 75, 162, 0.4); transition: transform 0.2s;
        }
        #btn-start:active { transform: scale(0.95); }

        #instructions {
            position: absolute; top: 20px; width: 100%; text-align: center;
            opacity: 0; transition: opacity 1s; pointer-events: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8); color: white;
        }
        .hint-text { font-size: 1.2rem; margin: 5px; color: #fff; font-weight: bold; letter-spacing: 1px; }
        .sub-hint { font-size: 0.9rem; color: rgba(255,255,255,0.6); }

        /* éŸ³é‡æ¢ */
        #mic-indicator {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 200px; height: 6px; background: rgba(255,255,255,0.1);
            border-radius: 3px; overflow: hidden; opacity: 0; transition: opacity 1s;
        }
        #mic-level {
            width: 0%; height: 100%; 
            background: linear-gradient(90deg, #00c6ff, #0072ff); 
            transition: width 0.05s;
        }

        video { position: absolute; opacity: 0; pointer-events: none; }
    </style>

    <script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-layer">
        <div id="version-tag">V6.0 Midnight</div>
        <div id="start-screen">
            <h1>ğŸŒŒ æ·±ç©ºæ³¡æ³¡è—è¡“</h1>
            <p style="color:#aaa;">è«‹å…è¨±ç›¸æ©Ÿèˆ‡éº¥å…‹é¢¨æ¬Šé™</p>
            <button id="btn-start" onclick="initExperience()">é€²å…¥é«”é©—</button>
        </div>
        <div id="instructions">
            <div class="hint-text">ğŸ˜® å°è‘—éº¥å…‹é¢¨ã€Œå‘¼å‘¼ã€å¹æ°£</div>
            <div class="sub-hint">ğŸ‘† é»æ“Šæ³¡æ³¡æˆ³ç ´å®ƒ</div>
        </div>
        <div id="mic-indicator"><div id="mic-level"></div></div>
    </div>

    <video id="input-video" playsinline webkit-playsinline muted></video>

    <script>
        let scene, camera, renderer;
        let bubbles = [];
        let audioContext, analyser, dataArray;
        let isBlowingMouth = false, isBlowingMic = false, micVolume = 0;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        async function initExperience() {
            const btn = document.getElementById('btn-start');
            btn.innerText = "å•Ÿå‹•ä¸­...";
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: 640, height: 480 }, audio: true });
                document.getElementById('input-video').srcObject = stream;
                document.getElementById('input-video').play();
                setupAudio(stream);
                initThreeJS(); 
                initAI(document.getElementById('input-video'));
                
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('instructions').style.opacity = 1;
                document.getElementById('mic-indicator').style.opacity = 1;
                window.addEventListener('pointerdown', onPointerDown);
            } catch (err) {
                alert("å•Ÿå‹•å¤±æ•—: " + err.message);
                btn.innerText = "é‡è©¦";
            }
        }

        function setupAudio(stream) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaStreamSource(stream);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            source.connect(analyser);
            dataArray = new Uint8Array(analyser.frequencyBinCount);
        }

        function updateMic() {
            if (!analyser) return;
            analyser.getByteFrequencyData(dataArray);
            let sum = 0;
            for(let i = 0; i < dataArray.length; i++) sum += dataArray[i];
            micVolume = sum / dataArray.length;
            document.getElementById('mic-level').style.width = Math.min(micVolume*1.5, 100) + '%';
            isBlowingMic = micVolume > 15; 
        }

        function onPointerDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(bubbles.map(b => b.mesh));
            if (intersects.length > 0) {
                const targetBubble = bubbles.find(b => b.mesh === intersects[0].object);
                if (targetBubble) targetBubble.pop();
            }
        }

        // --- æ³¡æ³¡æè³ª (V6: å¼·åŒ–è™¹å½©èˆ‡é€å…‰) ---
        const bubbleGeo = new THREE.SphereGeometry(1, 64, 64);
        let bubbleMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, 
            transmission: 1.0,  
            opacity: 1.0,
            transparent: true,
            roughness: 0.0,
            metalness: 0.1,
            thickness: 0.2, 
            ior: 1.5,
            reflectivity: 1,
            iridescence: 1.0,   // è™¹å½©å¼·åº¦
            iridescenceIOR: 1.33,
            iridescenceThicknessRange: [100, 800], // å¢åŠ åšåº¦ç¯„åœï¼Œè®“é¡è‰²æ›´è±å¯Œ
            envMapIntensity: 2.0 // å¢å¼·ç’°å¢ƒåå°„
        });

        function initThreeJS() {
            scene = new THREE.Scene();
            
            // --- V6 æ–°èƒŒæ™¯: æ·±é‚ƒå¤œç©ºæ¼¸å±¤ ---
            // é€™ç¨®æ·±è‰²èƒŒæ™¯èƒ½æœ€å¤§ç¨‹åº¦å‡¸é¡¯æ³¡æ³¡çš„äº®å…‰èˆ‡å½©è™¹è‰²
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const context = canvas.getContext('2d');
            const gradient = context.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, '#0f0c29');   // å¤œç©ºé»‘ç´«
            gradient.addColorStop(0.5, '#302b63'); // æ·±è—
            gradient.addColorStop(1, '#24243e');   // åº•éƒ¨æ·±ç°è—
            context.fillStyle = gradient;
            context.fillRect(0, 0, 512, 512);
            
            const bgTexture = new THREE.CanvasTexture(canvas);
            bgTexture.mapping = THREE.EquirectangularReflectionMapping;

            scene.background = bgTexture;
            bubbleMat.envMap = bgTexture; // æ³¡æ³¡åå°„é€™å€‹å¤œç©º
            bubbleMat.needsUpdate = true;

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.3));
            const dirLight = new THREE.DirectionalLight(0xffffff, 3);
            dirLight.position.set(-5, 10, 5);
            scene.add(dirLight);
            
            // å¢åŠ èƒŒå…‰ï¼Œè®“æ³¡æ³¡è¼ªå»“æ›´äº®
            const backLight = new THREE.DirectionalLight(0xaaaaff, 2);
            backLight.position.set(0, -5, -5);
            scene.add(backLight);

            animate();
        }

        class Bubble {
            constructor() {
                this.mesh = new THREE.Mesh(bubbleGeo, bubbleMat);
                const size = 0.25 + Math.random() * 0.3; // æ³¡æ³¡ç¨å¾®è®Šå¤§ä¸€é»
                this.mesh.scale.set(size, size, size);
                this.mesh.position.set((Math.random()-0.5)*0.8, -2.5, 0);
                this.speedY = 0.01 + Math.random() * 0.02;
                this.wobbleOffset = Math.random() * 100;
                this.isPopping = false;
                this.popScale = 1.0;
                scene.add(this.mesh);
            }
            update() {
                if (this.isPopping) {
                    this.popScale *= 1.2;
                    this.mesh.scale.setScalar(this.popScale * this.mesh.scale.x);
                    // å¿«é€Ÿç¸®å°ç›´åˆ°çœ‹ä¸è¦‹
                    if(this.popScale > 5) { return false; } 
                    return true;
                }
                const windForce = (micVolume / 100) * 0.1; 
                this.mesh.position.y += this.speedY + windForce; 
                this.mesh.position.x += Math.sin(Date.now()*0.001 + this.wobbleOffset) * 0.01;
                const wobble = Math.sin(Date.now()*0.003 + this.wobbleOffset)*0.05;
                this.mesh.scale.set(this.mesh.scale.x+wobble*0.01, this.mesh.scale.y-wobble*0.01, this.mesh.scale.z);
                
                return (this.mesh.position.y < 6);
            }
            pop() { if(!this.isPopping) this.isPopping = true; }
            dispose() { scene.remove(this.mesh); }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateMic();
            if ((isBlowingMouth || isBlowingMic) && Math.random() > 0.85) bubbles.push(new Bubble());
            for (let i = bubbles.length - 1; i >= 0; i--) {
                if (!bubbles[i].update()) { bubbles[i].dispose(); bubbles.splice(i, 1); }
            }
            renderer.render(scene, camera);
        }

        function initAI(videoElement) {
            const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
            faceMesh.setOptions({maxNumFaces: 1, minDetectionConfidence: 0.5});
            faceMesh.onResults((results) => {
                if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                    const lm = results.multiFaceLandmarks[0];
                    const h = Math.hypot(lm[13].x - lm[14].x, lm[13].y - lm[14].y);
                    const w = Math.hypot(lm[61].x - lm[291].x, lm[61].y - lm[291].y);
                    isBlowingMouth = ((h/w) > 0.4 && h > 0.01);
                }
            });
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await faceMesh.send({image: videoElement}); }, width: 640, height: 480
            });
            cameraUtils.start();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
