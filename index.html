<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D å¹æ³¡æ³¡æ¨¡æ“¬å™¨ (AI å˜´å‹åµæ¸¬)</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            /* 7. èƒŒæ™¯æ˜¯é»ƒæ˜ */
            background: linear-gradient(180deg, #6c4f70 0%, #ff9a76 60%, #ffc97e 100%);
            font-family: "Microsoft JhengHei", sans-serif;
            user-select: none;
        }
        
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* ç”¨æ–¼éš±è—åŸå§‹æ”å½±æ©Ÿç•«é¢ï¼Œæˆ‘å€‘åªéœ€è¦æ•¸æ“š */
        .input_video {
            display: none;
        }

        /* 3. è·³å‡ºè¦–çª—ä»‹é¢ */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: white;
            text-align: center;
        }

        button {
            padding: 15px 30px;
            font-size: 1.2rem;
            background: #ff9a76;
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 0 15px rgba(255, 154, 118, 0.5);
            transition: transform 0.2s;
        }
        button:active { transform: scale(0.95); }

        #status {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.3);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 10;
            pointer-events: none;
            font-size: 0.9rem;
        }

        #loading {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #ddd;
        }
    </style>
</head>
<body>

    <video class="input_video" playsinline></video>

    <div id="status">ç­‰å¾…ç›¸æ©Ÿæ¬Šé™...</div>

    <div id="start-screen">
        <h1>ğŸŒ… 3D å¹æ³¡æ³¡æ¨¡æ“¬å™¨</h1>
        <p>è«‹å…è¨±ç›¸æ©Ÿæ¬Šé™ä»¥åµæ¸¬å˜´å‹<br>å˜Ÿèµ·å˜´å·´ (Oå‹) å³å¯å¹å‡ºæ³¡æ³¡ï¼<br>å·¦å³è½‰é ­å¯æ”¹è®Šå¹æ°£æ–¹å‘</p>
        <div id="loading">æ­£åœ¨è¼‰å…¥ AI æ¨¡å‹...</div>
        <button id="start-btn" disabled>é–‹å§‹é«”é©—</button>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
        import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

        // --- å…¨åŸŸè®Šæ•¸ ---
        let scene, camera, renderer, controls;
        let bubbles = [];
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        
        // å˜´å‹åµæ¸¬è®Šæ•¸
        let isBlowing = false;
        let blowDirection = 0; // -1 (å·¦) ~ 1 (å³)
        let mouthPosition = new THREE.Vector3(0, 0, 0);

        // --- 1. Three.js åˆå§‹åŒ– ---
        function initThree() {
            const container = document.body;
            
            scene = new THREE.Scene();
            // ä¸è¨­å®š scene.backgroundï¼Œè®“ CSS çš„é»ƒæ˜èƒŒæ™¯é€å‡ºä¾†
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            // 10. æ³¡æ³¡ä¸æœƒä¸€é–‹å§‹å æ»¿è¢å¹• (æ‹‰é ç›¸æ©Ÿ)
            camera.position.set(0, 0, 30);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // 9. åŠ å…¥ç¸®æ”¾åŠŸèƒ½ (OrbitControls)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enablePan = false;
            controls.minDistance = 10;
            controls.maxDistance = 60;
            controls.zoomSpeed = 1.0;

            // ç‡ˆå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 2);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            // 6. ç›£è½é»æ“Šäº‹ä»¶ (æˆ³ç ´æ³¡æ³¡)
            window.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('resize', onWindowResize);
            
            animate();
        }

        // --- æ³¡æ³¡æè³ª (7. ç¬¦åˆå¹²æ¶‰çš„å…‰å½±è®ŠåŒ–) ---
        // ä½¿ç”¨ MeshPhysicalMaterial çš„ iridescence (è™¹å½©) å±¬æ€§
        const bubbleGeometry = new THREE.SphereGeometry(1, 64, 64);
        const bubbleMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            transmission: 1,      // å®Œå…¨é€å…‰
            opacity: 1,
            metalness: 0,
            roughness: 0,
            ior: 1.5,             // æŠ˜å°„ç‡
            thickness: 0.1,       // è–„è†œåšåº¦
            iridescence: 1,       // é–‹å•Ÿè™¹å½©æ•ˆæœ
            iridescenceIOR: 1.3,
            iridescenceThicknessRange: [100, 400], // è–„è†œåšåº¦ç¯„åœ (ç´ç±³)
            clearcoat: 1,
            side: THREE.DoubleSide
        });

        // --- ç”¢ç”Ÿæ³¡æ³¡é‚è¼¯ ---
        function createBubble() {
            // æ ¹æ“šå˜´å·´ä½ç½®ç”Ÿæˆæ³¡æ³¡ (å¾ç•«é¢ä¸­å¿ƒä¸‹æ–¹ç™¼å°„ï¼Œæ¨¡æ“¬ç¬¬ä¸€äººç¨±æˆ–å¾è¢å¹•ç™¼å‡º)
            const bubble = new THREE.Mesh(bubbleGeometry, bubbleMaterial.clone());
            
            // åˆå§‹ä½ç½®ï¼šéš¨æ©Ÿä¸€é»åç§»ï¼Œé¿å…é‡ç–Š
            bubble.position.set(
                (Math.random() - 0.5) * 2, 
                -5, 
                10 // å¾é›¢ç›¸æ©Ÿè¼ƒè¿‘çš„åœ°æ–¹ç”Ÿæˆ
            );

            // éš¨æ©Ÿå¤§å°
            const scale = 1 + Math.random() * 1.5;
            bubble.scale.set(scale, scale, scale);

            scene.add(bubble);

            // 8. æ¨¡æ“¬è‡ªç„¶é¢¨èˆ‡å¹æ°£æ–¹å‘
            // åŸºç¤å‘ä¸Šé£„çš„é€Ÿåº¦ + å˜´å·´æ–¹å‘çš„æ°´å¹³é€Ÿåº¦
            const speedX = blowDirection * 0.5 + (Math.random() - 0.5) * 0.1;
            
            bubbles.push({
                mesh: bubble,
                velocity: new THREE.Vector3(speedX, 0.1 + Math.random() * 0.1, -0.2), // ç¨å¾®å¾€é è™•é£„
                wobbleOffset: Math.random() * 100 // ç”¨æ–¼æ“ºå‹•
            });
        }

        // --- æˆ³ç ´æ³¡æ³¡ ---
        function onPointerDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            
            // æª¢æ¸¬æ‰€æœ‰æ³¡æ³¡
            const sceneBubbles = bubbles.map(b => b.mesh);
            const intersects = raycaster.intersectObjects(sceneBubbles);

            if (intersects.length > 0) {
                const hitObject = intersects[0].object;
                popBubble(hitObject);
            }
        }

        function popBubble(mesh) {
            scene.remove(mesh);
            // ç§»é™¤é™£åˆ—ä¸­çš„æ³¡æ³¡
            bubbles = bubbles.filter(b => b.mesh !== mesh);
            
            // å¯ä»¥åœ¨é€™è£¡åŠ å…¥ç ´æ‰çš„ç²’å­ç‰¹æ•ˆ (ç°¡åŒ–ç‰ˆï¼šç„¡ç‰¹æ•ˆç›´æ¥æ¶ˆå¤±)
        }

        // --- å‹•ç•«è¿´åœˆ ---
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;

            // å¦‚æœæ­£åœ¨å¹æ°£ï¼ŒæŒçºŒç”Ÿæˆæ³¡æ³¡
            if (isBlowing && Math.random() > 0.8) { // éš¨æ©Ÿé–“éš”ï¼Œä¸è¦å¤ªå¯†é›†
                createBubble();
            }

            // æ›´æ–°æ‰€æœ‰æ³¡æ³¡ä½ç½®
            for (let i = bubbles.length - 1; i >= 0; i--) {
                const b = bubbles[i];
                
                // 8. è‡ªç„¶é¢¨æ¨¡æ“¬ï¼šåŠ å…¥ä¸€äº›æ­£å¼¦æ³¢æ“¾å‹•
                b.mesh.position.add(b.velocity);
                b.mesh.position.y += Math.sin(time + b.wobbleOffset) * 0.02; 
                b.mesh.position.x += Math.cos(time * 0.5 + b.wobbleOffset) * 0.01;

                // æ—‹è½‰
                b.mesh.rotation.x += 0.01;
                b.mesh.rotation.z += 0.01;

                // å¦‚æœé£„å¤ªé æˆ–å¤ªé«˜ï¼Œç§»é™¤
                if (b.mesh.position.y > 50 || Math.abs(b.mesh.position.x) > 50 || b.mesh.position.z < -100) {
                    scene.remove(b.mesh);
                    bubbles.splice(i, 1);
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // å•Ÿå‹• Three.js
        initThree();

        // -----------------------------------------------------------
        // --- AI è‡‰éƒ¨åµæ¸¬é‚è¼¯ (MediaPipe) ---
        // -----------------------------------------------------------
        
        const videoElement = document.getElementsByClassName('input_video')[0];
        const statusElement = document.getElementById('status');
        const startBtn = document.getElementById('start-btn');
        const loadingText = document.getElementById('loading');

        // å˜´å·´ç‰¹å¾µé»ç´¢å¼• (MediaPipe FaceMesh)
        // ä¸Šå”‡: 13, ä¸‹å”‡: 14, å·¦å˜´è§’: 61, å³å˜´è§’: 291
        const UP_LIP = 13;
        const LOW_LIP = 14;
        const LEFT_CORNER = 61;
        const RIGHT_CORNER = 291;

        function onResults(results) {
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];

                // 1. è¨ˆç®—å˜´å·´å¯¬åº¦ (å·¦å³å˜´è§’è·é›¢)
                const mouthWidth = Math.hypot(
                    landmarks[LEFT_CORNER].x - landmarks[RIGHT_CORNER].x,
                    landmarks[LEFT_CORNER].y - landmarks[RIGHT_CORNER].y
                );

                // 2. è¨ˆç®—å˜´å·´é«˜åº¦ (ä¸Šä¸‹å”‡è·é›¢)
                const mouthHeight = Math.hypot(
                    landmarks[UP_LIP].x - landmarks[LOW_LIP].x,
                    landmarks[UP_LIP].y - landmarks[LOW_LIP].y
                );

                // 3. è¨ˆç®—é–‹åˆæ¯”ç‡ (é«˜åº¦ / å¯¬åº¦)
                // ç•¶å˜Ÿå˜´(Oå‹)æ™‚ï¼Œå¯¬åº¦è®Šçª„ï¼Œé«˜åº¦è®Šé«˜ï¼Œæ¯”ç‡æœƒä¸Šå‡
                const ratio = mouthHeight / mouthWidth;

                // é–¥å€¼åˆ¤å®šï¼šå¦‚æœæ¯”ç‡å¤§æ–¼ 0.6 (å¤§ç´„)ï¼Œè¦–ç‚ºå˜Ÿå˜´
                // åŒæ™‚å˜´å·´é«˜åº¦è¦æœ‰ä¸€å®šå¤§å° (é¿å…é–‰å˜´æ™‚èª¤åˆ¤)
                if (ratio > 0.6 && mouthHeight > 0.02) {
                    isBlowing = true;
                    statusElement.innerText = "ğŸŒ¬ï¸ æ­£åœ¨å¹æ°£ï¼";
                    statusElement.style.background = "rgba(0, 255, 0, 0.5)";
                } else {
                    isBlowing = false;
                    statusElement.innerText = "ğŸ˜ ç­‰å¾…å˜Ÿå˜´...";
                    statusElement.style.background = "rgba(0,0,0,0.3)";
                }

                // 5. åµæ¸¬å·¦å³æ–¹å‘ (åˆ©ç”¨è‡‰éƒ¨ä¸­å¿ƒé»çš„ x åº§æ¨™)
                // MediaPipe çš„ x åº§æ¨™æ˜¯ 0 (å·¦) åˆ° 1 (å³)
                // å› ç‚ºé¡é ­é€šå¸¸æ˜¯é¡åƒï¼Œæ‰€ä»¥è¦åéä¾†æ€è€ƒï¼Œæˆ–è€…ç›´æ¥å–å€¼
                const faceCenterX = landmarks[1].x; // é¼»é ­ä½ç½®
                
                // å°‡ 0~1 è½‰æ›ç‚º -1~1 çš„æ–¹å‘å€¼
                // ä¿®æ­£ï¼šå¤§éƒ¨åˆ†è‡ªæ‹é¡é ­æ˜¯é¡åƒçš„ï¼Œä½¿ç”¨è€…é ­å¾€å³(ç•«é¢å³é‚Š)ï¼Œæ•¸å€¼è®Šå¤§
                // æˆ‘å€‘å¸Œæœ›é ­å¾€å³è½‰(ç•«é¢å³é‚Š)ï¼Œæ³¡æ³¡å¾€å³é£›
                blowDirection = (0.5 - faceCenterX) * 5; // ä¹˜æ•¸èª¿æ•´éˆæ•åº¦
                
            } else {
                statusElement.innerText = "âš ï¸ åµæ¸¬ä¸åˆ°è‡‰éƒ¨";
            }
        }

        // åˆå§‹åŒ– FaceMesh
        const faceMesh = new FaceMesh({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
        }});
        
        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        faceMesh.onResults(onResults);

        // --- å•Ÿå‹•ç›¸æ©Ÿèˆ‡æµç¨‹æ§åˆ¶ ---
        
        startBtn.disabled = false;
        loadingText.style.display = 'none';

        startBtn.addEventListener('click', () => {
            document.getElementById('start-screen').style.display = 'none';
            
            // 3. å­˜å–ç›¸æ©Ÿ
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await faceMesh.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            cameraUtils.start();
        });

    </script>
</body>
</html>
