<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D æ³¡æ³¡ V7.0 (å…‰å½±èˆ‡æ–¹å‘)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: "å¾®è»Ÿæ­£é»‘é«”", sans-serif; user-select: none; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 100; pointer-events: none; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }

        #version-tag {
            position: absolute; top: 10px; right: 10px; color: #555; font-size: 12px;
        }

        #start-screen {
            pointer-events: auto; background: rgba(10,10,10,0.9);
            padding: 40px; border-radius: 20px; text-align: center;
            border: 1px solid #333; box-shadow: 0 0 50px rgba(255,165,0,0.2);
        }

        h1 {
            color: #fff; margin: 0 0 10px 0; font-size: 2rem;
            text-shadow: 0 0 10px #ffaa00;
        }

        #btn-start {
            background: #ffaa00; color: #000; border: none; padding: 15px 50px; font-size: 1.2rem;
            border-radius: 30px; cursor: pointer; margin-top: 20px; font-weight: bold;
            box-shadow: 0 0 20px rgba(255,170,0,0.5); transition: 0.2s;
        }
        #btn-start:hover { background: #ffcc00; box-shadow: 0 0 30px rgba(255,170,0,0.8); }

        #instructions {
            position: absolute; top: 20px; width: 100%; text-align: center;
            opacity: 0; transition: opacity 1s; pointer-events: none;
            color: white; text-shadow: 0 2px 4px #000;
        }
        
        /* è¦–è¦ºåŒ–çš„æ–¹å‘æŒ‡ç¤ºå™¨ */
        #wind-arrow {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 5rem; color: rgba(255,255,255,0.1); font-weight: bold;
            opacity: 0; transition: opacity 0.3s; pointer-events: none;
        }

        #mic-indicator {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 200px; height: 4px; background: #333;
            border-radius: 2px; overflow: hidden; opacity: 0; transition: opacity 1s;
        }
        #mic-level {
            width: 0%; height: 100%; background: #ffaa00; transition: width 0.05s;
        }

        video { position: absolute; opacity: 0; pointer-events: none; }
    </style>

    <script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-layer">
        <div id="version-tag">V7.0 Directional Light</div>
        <div id="wind-arrow">â¤</div> <div id="start-screen">
            <h1>ğŸ’¡ æš—æˆ¿å…‰å½±ç‰ˆ</h1>
            <p style="color:#888;">è«‹å˜—è©¦å·¦å³è½‰é ­å¹æ°£</p>
            <button id="btn-start" onclick="initExperience()">é–‹å•Ÿç‡ˆå…‰</button>
        </div>

        <div id="instructions">
            <div style="font-size: 1.2rem; font-weight: bold;">ğŸ˜® è©¦è‘—å¾€å³æˆ–å¾€å·¦å¹æ°£</div>
            <div style="font-size: 0.9rem; color: #aaa;">ç‡ˆå…‰åœ¨å³å´ï¼Œè§€å¯Ÿæ³¡æ³¡çš„é«˜å…‰</div>
        </div>
        <div id="mic-indicator"><div id="mic-level"></div></div>
    </div>

    <video id="input-video" playsinline webkit-playsinline muted></video>

    <script>
        let scene, camera, renderer;
        let bubbles = [];
        let audioContext, analyser, dataArray;
        let isBlowingMouth = false, isBlowingMic = false, micVolume = 0;
        
        // é—œéµè®Šæ•¸ï¼šé¢¨å‘èˆ‡å˜´å·´ä½ç½®
        let windDirectionX = 0; // -1 (å·¦) ~ 1 (å³)
        let mouthPosition = new THREE.Vector3(0, -2, 0); 
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        async function initExperience() {
            const btn = document.getElementById('btn-start');
            btn.innerText = "æš–æ©Ÿä¸­...";
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: 640, height: 480 }, audio: true });
                document.getElementById('input-video').srcObject = stream;
                document.getElementById('input-video').play();
                setupAudio(stream);
                initThreeJS(); 
                initAI(document.getElementById('input-video'));
                
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('instructions').style.opacity = 1;
                document.getElementById('mic-indicator').style.opacity = 1;
                window.addEventListener('pointerdown', onPointerDown);
            } catch (err) {
                alert("éŒ¯èª¤: " + err.message);
                btn.innerText = "é‡è©¦";
            }
        }

        function setupAudio(stream) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaStreamSource(stream);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            source.connect(analyser);
            dataArray = new Uint8Array(analyser.frequencyBinCount);
        }

        function updateMic() {
            if (!analyser) return;
            analyser.getByteFrequencyData(dataArray);
            let sum = 0;
            for(let i = 0; i < dataArray.length; i++) sum += dataArray[i];
            micVolume = sum / dataArray.length;
            document.getElementById('mic-level').style.width = Math.min(micVolume*1.5, 100) + '%';
            isBlowingMic = micVolume > 15; 
        }

        function onPointerDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(bubbles.map(b => b.mesh));
            if (intersects.length > 0) {
                const targetBubble = bubbles.find(b => b.mesh === intersects[0].object);
                if (targetBubble) targetBubble.pop();
            }
        }

        // --- æè³ª ---
        const bubbleGeo = new THREE.SphereGeometry(1, 64, 64);
        let bubbleMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, 
            transmission: 1.0,  
            opacity: 1.0,
            transparent: true,
            roughness: 0.0,    // æ¥µåº¦å…‰æ»‘ï¼Œç‚ºäº†åå°„é»å…‰æº
            metalness: 0.1,
            thickness: 0.1, 
            ior: 1.5,
            reflectivity: 1,
            iridescence: 1.0,
            iridescenceIOR: 1.33,
            iridescenceThicknessRange: [100, 800],
            clearcoat: 1.0,     // å¢åŠ äº®å…‰æ¼†å±¤ï¼Œè®“é«˜å…‰æ›´éŠ³åˆ©
            clearcoatRoughness: 0
        });

        function initThreeJS() {
            scene = new THREE.Scene();
            
            // 1. èƒŒæ™¯ï¼šç´”é»‘
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.body.appendChild(renderer.domElement);

            // 2. ç‡ˆå…‰ç³»çµ± (æš—æˆ¿é¢¨æ ¼)
            
            // å¾®å¼±çš„ç’°å¢ƒå…‰ï¼Œç¢ºä¿æ³¡æ³¡ä¸æœƒå®Œå…¨è®Šé»‘
            scene.add(new THREE.AmbientLight(0xffffff, 0.2));

            // ä¸»è§’ï¼šå³å´é»å…‰æº (æ¨¡æ“¬å–®ç‡ˆæ”å½±)
            const pointLight = new THREE.PointLight(0xffaa00, 5, 100); // æ©˜é»ƒè‰²å¼·å…‰
            pointLight.position.set(10, 2, 5); // æ”¾åœ¨å³å´ã€ç¨å¾®å‰æ–¹
            scene.add(pointLight);

            // è¼”åŠ©è¼ªå»“å…‰ (èƒŒå…‰)ï¼Œè®“æ³¡æ³¡é‚Šç·£æ›´æ¸…æ¥š
            const rimLight = new THREE.DirectionalLight(0x4444ff, 2); // è—è‰²å†·å…‰
            rimLight.position.set(-5, 0, -5); // å·¦å¾Œæ–¹
            scene.add(rimLight);

            animate();
        }

        class Bubble {
            constructor() {
                this.mesh = new THREE.Mesh(bubbleGeo, bubbleMat);
                const size = 0.2 + Math.random() * 0.3;
                this.mesh.scale.set(size, size, size);
                
                // 3. ç”Ÿæˆä½ç½®ï¼šè·Ÿéš¨å˜´å·´ä½ç½® (åŠ ä¸Šä¸€é»éš¨æ©Ÿåç§»)
                // å¦‚æœåµæ¸¬ä¸åˆ°å˜´å·´ï¼Œé è¨­å¾ä¸‹æ–¹
                const startX = mouthPosition.x * 3; // æ”¾å¤§æ¯”ä¾‹ä»¥å°æ‡‰è¢å¹•å¯¬åº¦
                const startY = mouthPosition.y * 3;
                this.mesh.position.set(startX + (Math.random()-0.5)*0.2, startY, 0);
                
                // 4. åˆå§‹é€Ÿåº¦ï¼šå—åˆ°ç•¶å‰ã€Œé¢¨å‘ã€å½±éŸ¿
                // åŸºç¤å‘ä¸Šé€Ÿåº¦ + é¢¨å‘æ°´å¹³é€Ÿåº¦
                const windForce = windDirectionX * 0.08; // é¢¨åŠ›ä¿‚æ•¸
                
                this.velocity = new THREE.Vector3(
                    windForce + (Math.random()-0.5)*0.01, // Xè»¸é€Ÿåº¦ (å—é ­è½‰å‘å½±éŸ¿å¤§)
                    0.03 + Math.random() * 0.02,          // Yè»¸é€Ÿåº¦ (å‘ä¸Š)
                    (Math.random()-0.5)*0.01              // Zè»¸é€Ÿåº¦ (å‰å¾Œå¾®å‹•)
                );

                this.wobbleOffset = Math.random() * 100;
                this.isPopping = false;
                this.popScale = 1.0;
                scene.add(this.mesh);
            }

            update() {
                if (this.isPopping) {
                    this.popScale *= 1.2;
                    this.mesh.scale.setScalar(this.popScale * this.mesh.scale.x);
                    if(this.popScale > 5) return false;
                    return true;
                }

                // æŒçºŒå—åˆ°é¢¨åŠ›å½±éŸ¿ (éŸ³é‡å¢å¼·æ¨åŠ›)
                const boost = (micVolume / 100) * 0.005;
                this.velocity.y += boost;
                this.velocity.x += windDirectionX * 0.002; // æŒçºŒæ–½åŠ é¢¨åŠ›

                this.mesh.position.add(this.velocity);

                // ç‰©ç†é˜»åŠ›
                this.velocity.multiplyScalar(0.98); 
                // å§‹çµ‚ä¿æŒä¸€é»é»å‘ä¸Šæµ®åŠ›
                this.velocity.y += 0.0005;

                // æ“ºå‹•æ•ˆæœ
                const wobble = Math.sin(Date.now()*0.005 + this.wobbleOffset)*0.05;
                this.mesh.scale.setScalar(this.mesh.scale.x + wobble*0.002);
                
                return (this.mesh.position.y < 6 && Math.abs(this.mesh.position.x) < 8);
            }
            pop() { if(!this.isPopping) this.isPopping = true; }
            dispose() { scene.remove(this.mesh); }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateMic();
            
            // è¦–è¦ºåŒ–ç®­é ­æ›´æ–°
            const arrow = document.getElementById('wind-arrow');
            if (Math.abs(windDirectionX) > 0.3) {
                arrow.style.opacity = 0.5;
                arrow.innerText = windDirectionX > 0 ? "â¤" : "â—„";
                arrow.style.transform = `translate(-50%, -50%) translateX(${windDirectionX * 50}px)`;
            } else {
                arrow.style.opacity = 0;
            }

            if ((isBlowingMouth || isBlowingMic) && Math.random() > 0.85) bubbles.push(new Bubble());
            
            for (let i = bubbles.length - 1; i >= 0; i--) {
                if (!bubbles[i].update()) { bubbles[i].dispose(); bubbles.splice(i, 1); }
            }
            renderer.render(scene, camera);
        }

        function initAI(videoElement) {
            const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
            faceMesh.setOptions({maxNumFaces: 1, minDetectionConfidence: 0.5});
            
            faceMesh.onResults((results) => {
                if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                    const lm = results.multiFaceLandmarks[0];

                    // A. å˜´å‹åˆ¤æ–· (å¹æ°£)
                    const mouthH = Math.hypot(lm[13].x - lm[14].x, lm[13].y - lm[14].y);
                    const mouthW = Math.hypot(lm[61].x - lm[291].x, lm[61].y - lm[291].y);
                    isBlowingMouth = ((mouthH/mouthW) > 0.35 && mouthH > 0.01);

                    // B. é ­éƒ¨æ–¹å‘åˆ¤æ–· (å·¦å³è½‰)
                    // æ¯”è¼ƒå·¦è‡‰é °(454)èˆ‡å³è‡‰é °(234)çš„ Z æ·±åº¦ (è·é›¢ç›¸æ©Ÿçš„é è¿‘)
                    // æ³¨æ„ï¼šMediaPipe é¡åƒæ¨¡å¼ä¸‹ï¼Œå·¦å³å¯èƒ½ç›¸åï¼Œéœ€å¯¦æ¸¬èª¿æ•´
                    // é‚è¼¯ï¼šçœ‹é¼»é ­(1)çš„ X åº§æ¨™ç›¸å°æ–¼å…©è€³ä¸­å¿ƒçš„ä½ç½®
                    // æˆ–è€…æ›´ç°¡å–®ï¼šä½¿ç”¨è‡‰é °çš„æ·±åº¦å·® (Zè»¸)
                    
                    const leftFaceZ = lm[454].z; // ç•«é¢å·¦é‚Š(ä½¿ç”¨è€…çš„å³è‡‰?)
                    const rightFaceZ = lm[234].z; // ç•«é¢å³é‚Š
                    
                    // è¨ˆç®—æ—‹è½‰é‡ (Yaw)
                    // å¦‚æœä½¿ç”¨è€…å¾€å³è½‰(ç•«é¢å³é‚Š)ï¼Œå·¦è‡‰é °æœƒé è¿‘ç›¸æ©Ÿ(zè®Šå°)ï¼Œå³è‡‰é °é é›¢(zè®Šå¤§)
                    // é€™è£¡çš„ä¿‚æ•¸ 10 æ˜¯ç‚ºäº†æ”¾å¤§æ—‹è½‰æ•ˆæœ
                    const yaw = (leftFaceZ - rightFaceZ) * 10; 
                    
                    // å¹³æ»‘éæ¸¡é¢¨å‘å€¼ (é¿å…æŠ–å‹•)
                    windDirectionX += (yaw - windDirectionX) * 0.1;

                    // C. æ›´æ–°å˜´å·´ä½ç½® (è®“æ³¡æ³¡å¾å˜´è£¡å‡ºä¾†)
                    // è½‰æ› MediaPipe åº§æ¨™ (0~1) åˆ° Three.js åº§æ¨™ (-1~1)
                    // ä¸Šä¸‹é¡›å€’ä¿®æ­£ï¼šMediaPipe Yå‘ä¸‹å¢åŠ ï¼ŒThree.js Yå‘ä¸Šå¢åŠ 
                    const mouthX = -(lm[13].x - 0.5) * 2; 
                    const mouthY = -(lm[13].y - 0.5) * 2; 
                    mouthPosition.set(mouthX, mouthY, 0);
                }
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await faceMesh.send({image: videoElement}); }, width: 640, height: 480
            });
            cameraUtils.start();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
